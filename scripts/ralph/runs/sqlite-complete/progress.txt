# SQLite Complete Migration - Progress Log

## Codebase Patterns

> Add reusable patterns discovered during implementation here.

### Type Conversion
- Always use `toISOString()` for Date → SQLite TEXT conversion, never `String(date)` or `toString()`
- Use `boolToSQLite(value): 0 | 1` for boolean → INTEGER conversion
- Use `safeParseJSON<T>(text, fallback)` for TEXT → object conversion

### SQL Best Practices
- Use `json_each()` for aggregating over JSON array columns
- Always use parameterized queries: `db.prepare('SELECT * FROM x WHERE id = ?').get(id)`
- Use `INSERT OR REPLACE INTO` for upsert operations

### Service Pattern
- Extend `BaseSQLiteService<T, TRow>` for all table services
- Define schema config with column mappings and type hints
- Keep query methods (getByX) in service class, not base class

---

## Architectural Decisions

### Hybrid Approach for Existing Services (Pre-Ralph Decision)

**Decision:** Use BaseSQLiteService for ALL NEW services, but do NOT refactor existing services.

**Context:**
- `clientService.ts` (702 lines) and `ticketService.ts` (~650 lines) already exist and work
- Refactoring 1,350+ lines of working code risks introducing bugs
- New services (40 of them) will benefit from BaseSQLiteService consistency

**Approach:**
1. Keep existing clientService and ticketService as-is
2. Use BaseSQLiteService pattern for all 40 new services
3. Only add MISSING methods to existing services (US-009)
4. Fix incomplete migration schemas (US-036, US-037)

**Future option:** Can optionally migrate existing services to BaseSQLiteService later if needed.

---

## Progress Log

> Each iteration appends below this line.

---

## 2026-01-17 - US-042: Type-safe conversion utilities
Commit: b4d58473b6a5a8538cc1ecd9311df9bcfe5acf72

**Why this story?** US-042 has no dependencies and is explicitly marked as the foundation story (priority 1) - all other services depend on these utilities.

**Changes:**
- `packages/sqlite-adapter/src/utils/typeConversions.ts` (NEW, 170 lines): Core conversion utilities
  - `toISOString(value)`: Converts Date/string/number to ISO 8601 string for SQLite TEXT storage
  - `boolToSQLite(value)`: Converts boolean-like values to 0/1 for SQLite INTEGER storage
  - `sqliteToBool(value)`: Inverse of boolToSQLite for reading back
  - `safeParseJSON<T>(value, fallback)`: Safe JSON parsing with type inference from fallback
  - `toJSONString(value)`: Safe JSON.stringify with circular reference handling
- `packages/sqlite-adapter/src/utils/index.ts` (NEW): Barrel export
- `packages/sqlite-adapter/src/index.ts:41-48`: Added exports for all conversion utilities
- `packages/sqlite-adapter/vitest.config.ts` (NEW): Package-specific test config (jsdom → node environment)
- `packages/sqlite-adapter/src/utils/__tests__/typeConversions.test.ts` (NEW, 270 lines): Comprehensive test suite

**Quality Checks:**
- Typecheck: PASS (new files only; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests covering all edge cases)
- Forbidden strings: PASS (no 'as any', 'void _')

**Learnings:**
- sqlite-adapter package needed its own vitest.config.ts with environment: 'node' (root config uses jsdom for React)
- Pre-existing typecheck errors in factory.ts (window undefined) and adapters (unused params) - not in scope to fix
- Added two bonus utilities (`sqliteToBool`, `toJSONString`) as inverse operations for completeness

**Patterns to sync:**
- Pattern: Package-specific vitest.config.ts - each package may need its own config with appropriate environment

**Next story suggestion:** US-001 (Create BaseSQLiteService) - it directly depends on US-042 and is the next logical step for building the service foundation.

---

## 2026-01-17 - US-001: Create BaseSQLiteService generic class
Commit: e00bc66

**Why this story?** US-001 depends on US-042 (just completed) and is the foundation class for all 40 new services. Priority 2 is highest among remaining stories with satisfied dependencies.

**Changes:**
- `packages/sqlite-adapter/src/services/BaseSQLiteService.ts` (NEW, 380 lines): Generic base service class
  - `BaseSQLiteService<T, TRow>`: Generic class with type parameters for app entity and SQLite row
  - CRUD operations: `getAll()`, `getById()`, `getByIds()`, `create()`, `update()`, `delete()`, `count()`
  - Schema config: `TableSchema` interface with tableName, primaryKey, and column mappings
  - Column definitions support type hints: `{ column: string, type: ColumnType, defaultValue?: unknown }`
  - Type conversion: Uses `boolToSQLite`, `sqliteToBool`, `toISOString`, `safeParseJSON`, `toJSONString` from US-042
  - Protected query helpers: `findWhere()`, `countWhere()`, `findOneWhere()`, `rawQuery()`, `rawQueryOne()`
- `packages/sqlite-adapter/src/services/index.ts:10-16`: Export BaseSQLiteService and related types
- `packages/sqlite-adapter/src/index.ts:27-31`: Export BaseSQLiteService from package root

**Quality Checks:**
- Typecheck: PASS (BaseSQLiteService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests from US-042 still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Schema config with type hints allows automatic conversion during `rowToEntity()` and `entityToRow()`
- Protected helpers (`findWhere`, `countWhere`) enable subclasses to build custom queries without SQL duplication
- Existing ClientSQLiteService (702 lines) follows similar pattern but with inline conversion - new services should use BaseSQLiteService

**Patterns to sync:**
- Pattern: TableSchema with ColumnDefinition - use `{ column: 'db_column', type: 'boolean' }` for typed columns

**Next story suggestion:** US-036 (Fix client schema with ALL columns) - depends on US-001 and fixes the incomplete migration schema needed before services can work properly.

---

## 2026-01-17 - US-036: Fix client schema with ALL columns
Commit: fd8d83e

**Why this story?** US-036 depends on US-001 (just completed) and has priority 3, the highest among remaining stories with satisfied dependencies. US-037 and all subsequent stories depend on US-036 being done first.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:52-134`: Expanded clients table from 8 to 50+ columns
  - Primary fields: id, store_id
  - Name fields: first_name, last_name, display_name, nickname, name
  - Contact fields: phone, email, avatar
  - Personal info: gender, birthday, anniversary, preferred_language
  - Complex JSON fields: address, emergency_contacts, staff_alert
  - Block fields: is_blocked (INTEGER), blocked_at, blocked_by, block_reason, block_reason_note
  - Source tracking: source, source_details, referred_by_client_id, referred_by_client_name
  - Profile JSON: hair_profile, skin_profile, nail_profile, medical_info
  - Preferences JSON: preferences, communication_preferences
  - Loyalty JSON: loyalty_info, loyalty_tier, membership, gift_cards
  - Visit stats: visit_summary, last_visit, total_visits (INTEGER), total_spent (REAL)
  - Balance: outstanding_balance (REAL), store_credit (REAL)
  - Reviews: average_rating (REAL), total_reviews (INTEGER)
  - Tags/notes: tags (JSON), notes (JSON)
  - VIP status: is_vip (INTEGER)
  - Timestamps: created_at, updated_at, sync_status
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:149-184`: Added 7 new indexes for clients
  - idx_clients_store: Basic store filter
  - idx_clients_store_lastname: [store_id+last_name] for alphabetical lists
  - idx_clients_store_vip: [store_id+is_vip] for VIP filtering
  - idx_clients_store_blocked: [store_id+is_blocked] for blocked filtering
  - idx_clients_store_created: [store_id+created_at] for date sorting
  - idx_clients_store_phone: [store_id+phone] for duplicate prevention
  - idx_clients_store_email: [store_id+email] for email lookup

**Quality Checks:**
- Typecheck: PASS (v001_initial_schema.ts passes; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests from US-042 still passing)
- Forbidden strings: PASS (no 'as any')

**Learnings:**
- Column names in SQLite use snake_case (store_id) while ClientRow interface matches them exactly
- Boolean fields use INTEGER type with DEFAULT 0 (is_blocked, is_vip)
- Numeric fields use REAL for decimals (total_spent, outstanding_balance) and INTEGER for counts (total_visits)
- JSON objects stored as TEXT columns (address, preferences, hair_profile, etc.)

**Patterns to sync:**
- Pattern: SQLite snake_case column naming - all columns use snake_case (store_id, first_name) matching ClientRow interface

**Next story suggestion:** US-037 (Fix ticket schema with ALL columns) - depends on US-036 (just completed) and is the next logical step to complete migration schemas before services can work.

---

## 2026-01-17 - US-037: Fix ticket schema with ALL columns
Commit: 10847c7

**Why this story?** US-037 is the only story with all dependencies met. It depends on US-036 (just completed) and both work on the same file (`v001_initial_schema.ts`), so the code structure is fresh in context.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:37-121`: Expanded tickets table from 8 to 45 columns matching TicketRow interface
  - Primary fields: id, number (INTEGER), store_id, appointment_id
  - Client fields: client_id, client_name, client_phone
  - Group ticket fields: is_group_ticket (INTEGER DEFAULT 0), clients (JSON)
  - Merged ticket fields: is_merged_ticket (INTEGER), merged_from_tickets, original_ticket_id, merged_at, merged_by
  - Services/products: services (JSON), products (JSON)
  - Status: status
  - Pricing fields: subtotal, discount, discount_reason, discount_percent, tax, tax_rate, tip, total (all REAL)
  - Payments: payments (JSON)
  - Timestamps: created_at, updated_at, completed_at
  - Audit: created_by, last_modified_by, sync_status
  - Draft fields: is_draft (INTEGER), draft_expires_at, last_auto_save_at
  - Source: source
  - Service charges: service_charges (JSON), service_charge_total
  - Staff: staff_id, staff_name, payment_method
  - Closing: closed_at, closed_by
  - Signature: signature_base64, signature_timestamp
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:217-252`: Added 6 indexes for tickets
  - idx_tickets_store_status: [store_id+status] for status filtering
  - idx_tickets_store_created: [store_id+created_at] for date sorting
  - idx_tickets_client_created: [client_id+created_at] for client ticket history
  - idx_tickets_store_status_created: [store_id+status+created_at] for turn queue queries
  - idx_tickets_store_staff_created: [store_id+staff_id+created_at] for staff reports
  - idx_tickets_store_appointment: [store_id+appointment_id] for appointment lookup

**Quality Checks:**
- Typecheck: PASS (v001_initial_schema.ts passes; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any')

**Learnings:**
- Ticket pricing fields (subtotal, discount, tax, tip, total) use REAL type with DEFAULT 0 for numeric safety
- JSON array columns (services, products, payments, clients, merged_from_tickets) use TEXT with NOT NULL where required
- Staff assignment fields (staff_id, staff_name) are nullable - primary staff can be derived from services array
- Both client and ticket schemas now complete - ready for schema registry (US-002)

**Patterns to sync:**
- Pattern: Required JSON arrays - use `TEXT NOT NULL` for JSON arrays that must always exist (even if empty `[]`)

**Next story suggestion:** US-002 (Create TableSchema type and registry) - depends on US-037 (just completed) and is the foundation for type-safe schema definitions used by all services.

---

## 2026-01-17 - US-002: Create TableSchema type and registry
Commit: 17f2330

**Why this story?** US-002 is the only story with all dependencies satisfied. It depends on US-037 (just completed) and provides the schema registry foundation needed by all subsequent services (US-005, US-006, etc.).

**Changes:**
- `packages/sqlite-adapter/src/schema/types.ts` (NEW, 145 lines): Schema type definitions
  - `ColumnType`: Union type for column data types ('string'|'number'|'boolean'|'json'|'date')
  - `ColumnSchema`: Full column definition interface (name, dbColumn, type, defaultValue, nullable)
  - `ColumnDefinition`: Simplified column definition for BaseSQLiteService compatibility
  - `ColumnMapping`: Union of string shorthand or ColumnDefinition
  - `TableSchema`: Main interface with tableName, primaryKey, columns Record
  - `ExtendedTableSchema`: Extended version with description, indexes, foreignKeys
  - `ForeignKeySchema`: Foreign key relationship definition
  - `SchemaRegistry<T>`: Generic registry type for type-safe table lookup
  - `CoreTableName`, `InfrastructureTableName`, `AllTableName`: Table name union types
- `packages/sqlite-adapter/src/schema/registry.ts` (NEW, 340 lines): Schema definitions for 6 core tables
  - `appointmentsSchema`: Scheduled appointments with services JSON, dates
  - `ticketsSchema`: All 45 columns matching v001 migration, with pricing fields, JSON arrays
  - `clientsSchema`: All 50+ columns matching v001 migration, with profiles, preferences
  - `staffSchema`: Staff with schedule JSON, skills, status
  - `servicesSchema`: Menu services with pricing, add-ons, variants as JSON
  - `transactionsSchema`: Payment transactions with card details, refund info
  - `schemaRegistry`: Type-safe lookup object for all core tables
  - Helper functions: `getSchema()`, `hasSchema()`, `getTableNames()`
- `packages/sqlite-adapter/src/schema/index.ts` (NEW, 35 lines): Barrel export for all schema types and registry
- `packages/sqlite-adapter/src/index.ts:57-83`: Export schema types and registry from package root
  - Aliased `ColumnType` as `SchemaColumnType` to avoid collision with services export

**Quality Checks:**
- Typecheck: PASS (new schema files have no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Schema registry provides type-safe lookup: `schemaRegistry.clients` returns ClientSchema
- ColumnMapping union (string | ColumnDefinition) allows both shorthand (`'store_id'`) and full definition (`{ column: 'is_blocked', type: 'boolean' }`)
- ExtendedTableSchema adds metadata for documentation/migration - useful for future tooling
- Exported `SchemaColumnType` alias to avoid name collision with `ColumnType` already exported from services

**Patterns to sync:**
- Pattern: Schema registry with type-safe lookup - use `SchemaRegistry<TableName>` for compile-time table name validation

**Next story suggestion:** US-005 (Create AppointmentSQLiteService) - depends on US-002 (just completed) and is the first service to use the new schema registry pattern.

---

## 2026-01-17 - US-005: Create AppointmentSQLiteService
Commit: ed115c0

**Why this story?** US-005 is the only story with all dependencies satisfied. It depends on US-002 (just completed) and is the first SQLite service to use BaseSQLiteService for handling scheduled appointments.

**Changes:**
- `packages/sqlite-adapter/src/services/appointmentService.ts` (NEW, 290 lines): Appointment SQLite service
  - `AppointmentSQLiteService`: Extends BaseSQLiteService<Appointment, AppointmentRow>
  - `getByDateRange(storeId, start, end)`: Calendar view queries using SQL BETWEEN
  - `getByStaff(staffId, date?)`: Staff schedule queries with optional date filter
  - `getByClient(clientId)`: Client appointment history
  - `getByStatus(storeId, status)`: Dashboard filtering by appointment status
  - `getUpcoming(storeId, hours)`: Appointments starting within N hours (excludes cancelled/no-show)
  - `getToday(storeId)`: Convenience method for today's appointments
  - `getByStore(storeId)`: All appointments for a store with pagination
  - `countByStatus(storeId, status)`: Dashboard metrics
  - Helper methods: `updateStatus()`, `checkIn()`, `startService()`, `complete()`, `cancel()`, `markNoShow()`
- `packages/sqlite-adapter/src/services/index.ts:38-46`: Export AppointmentSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:46-52`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (appointmentService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Appointment table uses camelCase column names (unlike clients/tickets which use snake_case) - schema must match
- Interface must extend `Record<string, unknown>` to satisfy BaseSQLiteService constraint
- Date range queries use ISO string comparison which works correctly with SQLite's string ordering
- Services array stored as JSON TEXT column with `type: 'json'` for automatic serialization

**Patterns to sync:**
- Pattern: Interface extends Record<string, unknown> - entity types used with BaseSQLiteService must satisfy this constraint

**Next story suggestion:** US-006 (Create TransactionSQLiteService) - depends on US-005 and follows the same service pattern for payment transactions.

---

## 2026-01-17 - US-006: Create TransactionSQLiteService
Commit: ee71593

**Why this story?** US-006 is the only story with all dependencies satisfied. It depends on US-005 (just completed) and follows the same service pattern for payment transactions with SQL aggregation queries.

**Changes:**
- `packages/sqlite-adapter/src/services/transactionService.ts` (NEW, 310 lines): Transaction SQLite service
  - `TransactionSQLiteService`: Extends BaseSQLiteService<Transaction, TransactionRow>
  - `getByTicket(ticketId)`: All transactions for a ticket (checkout flow)
  - `getByDateRange(storeId, start, end)`: Date range queries for reporting
  - `getTotalByDateRange(storeId, start, end)`: SQL SUM aggregation (no JS reduce) - returns TransactionTotals
  - `getByPaymentMethod(storeId, method)`: Filter by payment type for analytics
  - `getByClient(clientId)`: Client transaction history
  - `getByStatus(storeId, status)`: Filter by transaction status
  - `getTotalsByPaymentMethod(storeId, start, end)`: SQL GROUP BY for payment method breakdown
  - `getByStore(storeId)`: All transactions for a store with pagination
  - `countByStatus(storeId, status)`: Dashboard metrics
  - Helper methods: `updateStatus()`, `recordRefund()`, `void()`, `getTodayTotal()`
  - Types: `Transaction`, `TransactionRow`, `TransactionTotals`, `TotalsByPaymentMethod`, `PaymentMethod`, `TransactionStatus`
- `packages/sqlite-adapter/src/services/index.ts:48-57`: Export TransactionSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:53-60`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (transactionService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- SQL aggregation with COALESCE handles null values: `COALESCE(SUM(amount), 0) as total_amount`
- TransactionTotals includes computed field `netAmount = totalAmount - refundedAmount`
- GROUP BY queries return array of objects - map to TypeScript interface for type safety
- recordRefund method determines partial vs full refund status based on cumulative amount

**Patterns to sync:**
- Pattern: SQL aggregation with COALESCE - use `COALESCE(SUM(column), 0)` to handle null values in aggregations

**Next story suggestion:** US-007 (Create StaffSQLiteService) - depends on US-006 and continues the service pattern for staff with availability queries.

---

## 2026-01-17 - US-007: Create StaffSQLiteService
Commit: 6e43671

**Why this story?** US-007 is the only story with all dependencies satisfied. It depends on US-006 (just completed) and follows the same service pattern for staff members with availability queries.

**Changes:**
- `packages/sqlite-adapter/src/services/staffService.ts` (NEW, 340 lines): Staff SQLite service
  - `StaffSQLiteService`: Extends BaseSQLiteService<Staff, StaffRow>
  - `getAvailable(storeId)`: Staff with status != 'off' (for scheduling)
  - `getByStatus(storeId, status)`: Filter by status (available, busy, break, off)
  - `updateStatus(id, status)`: Quick status update for real-time changes
  - `getActive(storeId)`: Only active (non-deleted) staff members
  - `getByRole(storeId, role)`: Filter by role for permissions
  - `getByStore(storeId)`: All staff for a store with pagination
  - `countByStatus(storeId, status)`: Dashboard metrics
  - `countActive(storeId)`: Count of active staff
  - `softDelete(id)`: Sets isActive=false and status='off'
  - `restore(id)`: Sets isActive=true and status='available'
  - `updateSchedule(id, schedule)`: Update schedule JSON
  - `getBySkill(storeId, skill)`: Find staff with specific skill using json_each()
  - `search(storeId, query)`: Search by name using LIKE
  - `getStatusCounts(storeId)`: SQL GROUP BY for status breakdown
  - `getByEmail(email)`, `getByPhone(phone)`: Lookup by contact
  - Types: `Staff`, `StaffRow`, `StaffStatus`, `StaffRole`, `StaffSchedule`, `ScheduleEntry`
- `packages/sqlite-adapter/src/services/index.ts:59-67`: Export StaffSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:61-68`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (staffService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- json_each() is useful for searching within JSON array columns: `SELECT s.* FROM staff s, json_each(s.skills) AS skill WHERE skill.value = ?`
- Staff status is a 4-state enum ('available', 'busy', 'break', 'off') used for real-time availability
- Soft delete pattern: set isActive=false instead of actual deletion, also set status='off'
- SQL GROUP BY with initialization pattern: start with all keys at 0, then fill from query results

**Patterns to sync:**
- Pattern: JSON array search with json_each() - use `json_each(column) AS alias WHERE alias.value = ?` to search within JSON arrays

**Next story suggestion:** US-008 (Create ServiceSQLiteService) - depends on US-007 and continues the service pattern for menu services with category filtering.

---

## 2026-01-17 - US-008: Create ServiceSQLiteService
Commit: 15e5bbb

**Why this story?** US-008 is the only story with all dependencies satisfied. It depends on US-007 (just completed in the last iteration) and continues the same service pattern for menu services with category filtering and search.

**Changes:**
- `packages/sqlite-adapter/src/services/serviceService.ts` (NEW, 330 lines): Service SQLite service
  - `ServiceSQLiteService`: Extends BaseSQLiteService<Service, ServiceRow>
  - `getByCategory(storeId, category)`: Filter services by category (for menu views)
  - `getActive(storeId)`: Only active services (for booking flow)
  - `search(storeId, query)`: Name/description search using SQL LIKE
  - `getByStore(storeId)`: All services with pagination (for admin views)
  - `getCategories(storeId)`: Get distinct category names for navigation
  - `countByCategory(storeId)`: SQL GROUP BY for category breakdown
  - `countActive(storeId)`: Count of active services
  - `softDelete(id)`, `restore(id)`: Soft delete pattern
  - `updateDisplayOrder(updates)`: Batch update for menu reordering
  - `getByPriceRange(storeId, min, max)`: Price range filtering
  - `getByDurationRange(storeId, min, max)`: Duration range filtering
  - `getPopular(storeId, limit)`: Popular services (by display order)
  - Types: `Service`, `ServiceRow`, `ServiceAddOn`, `ServiceVariant`
- `packages/sqlite-adapter/src/services/index.ts:70-77`: Export ServiceSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:69-74`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (serviceService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Services table uses snake_case columns (store_id, is_active, display_order) matching schema convention
- Added extra query methods beyond acceptance criteria (price range, duration range, categories) for completeness
- displayOrder field is critical for menu presentation - batch update method supports drag-and-drop reordering

**Patterns to sync:** None new - follows established BaseSQLiteService patterns

**Next story suggestion:** US-009 (Add missing methods to TicketSQLiteService) - depends on US-008 (just completed) and requires reviewing existing ticketService.ts to identify any missing methods.

---

## 2026-01-17 - US-009: Add missing methods to TicketSQLiteService
Commit: dbbbe21

**Why this story?** US-009 is the only story with all dependencies satisfied. It depends on US-008 (just completed) and modifies the same category of files (sqlite-adapter services).

**Existing Methods Identified (before changes):**
- getAll, getById, getByStatus, getActive, getByDate
- getStaffTicketCounts, getDailyStats
- create, update, delete
- getCount, getCompletedInRange, getDrafts

**Missing Methods Added (to match Dexie ticketsDB interface):**
- `packages/sqlite-adapter/src/services/ticketService.ts:726-997`: Added 7 new methods (272 lines)
  - `addRaw(ticket)`: Insert raw ticket objects directly using INSERT OR REPLACE
  - `complete(id, userId)`: Mark ticket as paid/completed with timestamp
  - `createDraft(services, userId, storeId, clientInfo?)`: Create draft tickets with 24h expiration
  - `cleanupExpiredDrafts(storeId)`: Delete expired drafts and return count
  - `getByClient(clientId, limit)`: Client ticket history queries
  - `getByDateRange(storeId, start, end, limit)`: Date range queries for reporting
  - `getPending(storeId, limit)`: Convenience method wrapping getByStatus('pending')

**Quality Checks:**
- Typecheck: PASS (ticketService.ts specific check passes; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Dexie ticketsDB has methods SQLite didn't: addRaw, complete, createDraft, cleanupExpiredDrafts
- addRaw uses INSERT OR REPLACE for upsert semantics matching Dexie's .put() behavior
- createDraft includes default taxRate (0.0875) matching TAX_RATE constant in store-app
- cleanupExpiredDrafts finds and deletes in two queries (SELECT then DELETE) for clarity

**Patterns to sync:** None new - follows established service patterns

**Next story suggestion:** US-040 (Optimize getStaffTicketCounts with SQL json_each) - depends on US-009 (just completed) and optimizes the same file's aggregation method.

---

## 2026-01-17 - US-040: Optimize getStaffTicketCounts with SQL json_each
Commit: 2a67b98

**Why this story?** US-040 is the only story with all dependencies satisfied. It depends on US-009 (just completed) and works on the same file (ticketService.ts), so the code structure is fresh in context.

**Changes:**
- `packages/sqlite-adapter/src/services/ticketService.ts:387-445`: Optimized getStaffTicketCounts method
  - Replaced JS-based counting loop with SQL json_each() aggregation
  - Old approach: Loaded all tickets into memory, parsed JSON services array in JS, counted in loops
  - New approach: Single SQL query using `json_each(tickets.services)` with `GROUP BY`
  - SQL pattern: `SELECT json_extract(service.value, '$.staffId') as staff_id, COUNT(*) FROM tickets, json_each(tickets.services) as service WHERE ... GROUP BY staff_id`
  - Filters out NULL staffId values to avoid edge cases
  - Still initializes all requested staffIds to 0 for consistent return type
  - Expected performance: <100ms for 10k tickets (vs 500ms+ with old JS loops)

**Quality Checks:**
- Typecheck: PASS (ticketService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- SQLite's json_each() function creates virtual rows for each JSON array element, enabling GROUP BY aggregation
- Must alias the json_each result (e.g., `as service`) to reference it in json_extract
- json_extract(value, '$.fieldName') extracts fields from JSON objects within the array
- This pattern eliminates memory-intensive loading of all tickets for counting operations

**Patterns to sync:**
- Pattern: SQL aggregation over JSON arrays - use `json_each(table.json_column) as alias` with `GROUP BY json_extract(alias.value, '$.field')` for in-database JSON array aggregation

**Next story suggestion:** US-003 (Wire dataService to use SQLite services) - depends on US-040 (just completed) and is the critical integration point that routes dataService to SQLite implementations.

---

## 2026-01-17 - US-003: Wire dataService to use SQLite services
Commit: 308f0e2

**Why this story?** US-003 is the only story with all dependencies satisfied. It depends on US-040 (just completed) and is the critical integration point that routes dataService methods to SQLite implementations when the feature flag is enabled.

**Changes:**
- `apps/store-app/src/services/sqliteServices.ts` (NEW, 560 lines): SQLite service wrappers with lazy initialization
  - Imports all services from @mango/sqlite-adapter package
  - Lazy initialization pattern via `initializeSQLite()` to avoid loading SQLite on web platform
  - Creates adapter with Electron config (better-sqlite3 expected)
  - Runs migrations (v001, v002) on first initialization
  - `sqliteClientsDB`: Full Dexie-compatible API with all 9 methods (getAll, getById, create, update, delete, getFiltered, count, getAllByIds, bulkCreate)
  - `sqliteTicketsDB`: All ticket methods including getStaffTicketCounts, getDailyStats, createDraft, cleanupExpiredDrafts
  - `sqliteAppointmentsDB`: All appointment methods with date range queries
  - `sqliteTransactionsDB`: All transaction methods with aggregation support
  - `sqliteStaffDB`: All staff methods with status management
  - `sqliteServicesDB`: All service/menu item methods with category filtering
  - Uses `unknown` intermediate casts to bridge type differences between store-app and sqlite-adapter
- `apps/store-app/src/services/dataService.ts:7-14`: Added import for SQLite service wrappers
- `apps/store-app/src/services/dataService.ts:68-220`: Routed clients service to SQLite when USE_SQLITE flag is true
  - All 9 clientsService methods now check USE_SQLITE and route accordingly
  - Added backend selection log message on first use: `[DataService] Using SQLite backend for clients`
- `apps/store-app/package.json:31`: Added `"@mango/sqlite-adapter": "workspace:*"` dependency
- `packages/sqlite-adapter/src/index.ts:17`: Added migration exports (migration_001, migration_002)
- `packages/sqlite-adapter/src/index.ts:71`: Fixed duplicate identifier by renaming `Service as SQLiteServiceType`

**Quality Checks:**
- Typecheck: PASS (0 errors in modified files; 367 pre-existing errors in test files unrelated)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Type bridging between packages requires `unknown` intermediate casts: `result as unknown as Client`
- Lazy initialization is critical - web platform shouldn't load SQLite adapter at all
- Workspace dependencies need explicit addition to package.json even for internal packages
- Migration exports must be re-exported from package index for external consumption
- TicketSQLiteService methods have different signatures than Dexie - must adapt create() and update() calls

**Patterns to sync:**
- Pattern: Lazy SQLite initialization - use `let _initPromise: Promise<void> | null = null` pattern to ensure single initialization
- Pattern: Type bridging between packages - use `result as unknown as TargetType` when packages have similar but not identical type definitions

**Next story suggestion:** US-004 (Enhance migration system for full schema) - depends on US-003 (just completed) and creates migration v003 for all infrastructure tables.

---

## 2026-01-17 - US-004: Enhance migration system for full schema
Commit: cf2cede

**Why this story?** US-004 is the only story with all dependencies satisfied. It depends on US-003 (just completed) and creates the infrastructure tables (settings, syncQueue, deviceSettings) plus transactions table needed for remaining service wiring.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v003_full_schema.ts` (NEW, 168 lines): Infrastructure and transactions migration
  - `settings` table: Simple key-value store with `key` as PRIMARY KEY
  - `sync_queue` table: Offline sync operation queue with priority, status, retry_count, error_message
  - `device_settings` table: Device-specific configuration (device_id as PRIMARY KEY)
  - `transactions` table: Full payment transaction records matching Dexie v16 schema
    - Card details: card_last_four, card_brand, card_holder_name
    - Authorization: authorization_code, reference_number, processor_response
    - Refund tracking: refunded_amount, refund_reason, refunded_at, original_transaction_id
    - Void tracking: voided_at, voided_by, void_reason
  - Indexes: sync_queue(status, created_at, priority, entity), transactions(store_id+created_at, client_id+created_at, ticket_id, status, payment_method)
  - `down()` function that drops tables in reverse order
- `packages/sqlite-adapter/src/migrations/index.ts:21`: Export migration_003

**Quality Checks:**
- Typecheck: PASS (new migration file has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any')

**Learnings:**
- Sync queue needs both priority index and status+created_at compound index for efficient queue processing
- Transaction table uses snake_case column names (store_id, ticket_id) consistent with existing migrations
- Device settings table uses device_id (not auto-generated id) as PRIMARY KEY matching Dexie schema

**Patterns to sync:** None new - follows established migration patterns

**Next story suggestion:** US-010 (Wire remaining core services to dataService) - depends on US-004 (just completed) and wires appointments, transactions, staff, services, tickets to SQLite.

---

## 2026-01-17 - US-010: Wire remaining core services to dataService
Commit: c4aae6b

**Why this story?** US-010 is the only story with all dependencies satisfied. It depends on US-004 (just completed) and completes the dataService routing by wiring all remaining core services (staff, services, appointments, tickets, transactions) to SQLite.

**Changes:**
- `apps/store-app/src/services/dataService.ts:511-616`: Wired staffService to SQLite
  - All 8 methods (getAll, getById, getActive, create, update, delete, clockIn, clockOut) now route to sqliteStaffDB when USE_SQLITE=true
  - Added JSDoc comment documenting SQLite routing
- `apps/store-app/src/services/dataService.ts:618-665`: Wired servicesService to SQLite
  - All 4 methods (getAll, getById, getActive, getByCategory) now route to sqliteServicesDB when USE_SQLITE=true
- `apps/store-app/src/services/dataService.ts:667-773`: Wired appointmentsService to SQLite
  - All 9 methods (getByDate, getById, create, update, getUpcoming, updateStatus, delete, checkIn) now route to sqliteAppointmentsDB when USE_SQLITE=true
- `apps/store-app/src/services/dataService.ts:775-953`: Wired ticketsService to SQLite
  - All 14 methods (getByDate, getById, getOpenTickets, getByStatus, getByClientId, getByAppointmentId, create, update, updateStatus, complete, delete, getDailySummary, getUpdatedSince, getDrafts, createDraft) now route to sqliteTicketsDB when USE_SQLITE=true
- `apps/store-app/src/services/dataService.ts:955-1114`: Wired transactionsService to SQLite
  - All 10 methods (getByDate, getById, getByTicketId, getByClientId, getByPaymentMethod, create, update, delete, getDailySummary, getPaymentBreakdown, getUpdatedSince) now route to sqliteTransactionsDB when USE_SQLITE=true
- `apps/store-app/src/services/sqliteServices.ts:397`: Fixed sqliteTransactionsDB.create signature
  - Changed from `Omit<Transaction, 'id' | 'createdAt'>` to `Omit<Transaction, 'id' | 'createdAt' | 'syncStatus'>`
  - Added default syncStatus: 'local' in implementation to match SQLite service expectations

**Quality Checks:**
- Typecheck: PASS (0 errors in modified files; pre-existing errors in test files unrelated)
- Tests: PASS (62 tests in sqlite-adapter still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Consistent pattern for routing: check `USE_SQLITE` flag at start of each method, route to sqliteXDB or dexieDB accordingly
- Return types must be normalized (e.g., `updated ?? null` for undefined → null conversion)
- Some methods require different variable types for unified handling (e.g., `let updated: Staff | null | undefined`)
- sqliteTransactionsDB.create needed signature adjustment to match dataService's expected input without syncStatus

**Patterns to sync:** None new - follows established SQLite routing pattern from US-003

**Next story suggestion:** US-011 (Create SettingsSQLiteService) - depends on US-010 (just completed) and adds the simple key-value settings service.

---

## 2026-01-17 - US-011: Create SettingsSQLiteService
Commit: 451b22e

**Why this story?** US-011 is the only story with all dependencies satisfied. It depends on US-010 (just completed in the previous iteration) and is a simple key-value service that follows established patterns. Priority 15 is highest among remaining stories.

**Changes:**
- `packages/sqlite-adapter/src/services/settingsService.ts` (NEW, 335 lines): Key-value settings service
  - `SettingsSQLiteService`: Standalone service (not extending BaseSQLiteService since key-value pattern differs)
  - `get<T>(key)`: Retrieve setting by key with generic type support
  - `getWithMetadata(key)`: Get setting with full metadata (createdAt, updatedAt)
  - `set(key, value)`: Upsert setting using INSERT OR REPLACE
  - `getAll()`: All settings as key-value object
  - `getAllWithMetadata()`: All settings as Setting objects with metadata
  - `delete(key)`: Remove setting by key
  - `exists(key)`: Check if setting exists
  - `getMany(keys)`: Get multiple settings by keys
  - `setMany(settings)`: Set multiple settings at once
  - `deleteMany(keys)`: Delete multiple settings
  - `getByPrefix(prefix)`: Get settings matching key prefix (e.g., 'feature.')
  - `deleteByPrefix(prefix)`: Delete settings matching key prefix
  - `count()`: Total settings count
  - `clear()`: Delete all settings
  - Types: `Setting`, `SettingValue` (union of JSON-serializable types)
- `packages/sqlite-adapter/src/services/index.ts:79-84`: Export SettingsSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:75-78`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (no errors in settingsService.ts; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Settings service uses standalone pattern rather than BaseSQLiteService since key-value store has different primary key semantics (key is string, not id)
- INSERT OR REPLACE with COALESCE preserves original created_at on update: `COALESCE((SELECT created_at FROM settings WHERE key = ?), ?)`
- Generic type `get<T>` allows typed retrieval: `settings.get<boolean>('darkMode')`
- Added prefix-based queries for namespaced settings (e.g., 'feature.darkMode', 'feature.beta')

**Patterns to sync:**
- Pattern: Key-value service with prefix queries - use `LIKE ? || '%'` for prefix-based key matching

**Next story suggestion:** US-012 (Create SyncQueueSQLiteService) - depends on US-011 (just completed) and adds the offline sync queue service.

---

## 2026-01-17 - US-012: Create SyncQueueSQLiteService
Commit: a47626a

**Why this story?** US-012 is the only story with all dependencies satisfied. It depends on US-011 (just completed) and is the offline sync queue service critical for offline-first architecture. Priority 16 is highest among remaining stories.

**Changes:**
- `packages/sqlite-adapter/src/services/syncQueueService.ts` (NEW, 450 lines): Offline sync queue service
  - `SyncQueueSQLiteService`: Standalone service for managing sync operations queue
  - `add(input)`: Add operation to queue with entity, entityId, operation, data, priority
  - `getNext(limit)`: Get pending operations ordered by priority (1=high) then createdAt (FIFO)
  - `markComplete(id)`: Mark operation as successfully synced
  - `markFailed(id, error)`: Increment retry count, mark failed if max retries reached
  - `getPending()`: Get all pending operations
  - `clearCompleted()`: Remove completed operations from queue
  - Additional methods: `getById()`, `getByEntity()`, `getByEntityId()`, `getByStatus()`
  - `markSyncing(id)`: Mark operation as currently in progress
  - `resetForRetry(id)`: Reset failed operation to pending for manual retry
  - `countByStatus()`: Get counts for each status (pending, syncing, complete, failed)
  - `getStats()`: Get queue statistics including oldest pending timestamp
  - `getHighPriority(limit)`: Get high priority (1) pending operations
  - Types: `SyncQueueOperation`, `AddSyncOperationInput`, `SyncPriority`, `SyncStatus`, `SyncEntity`, `SyncOperation`
- `packages/sqlite-adapter/src/services/index.ts:87-94`: Export SyncQueueSQLiteService and all types
- `packages/sqlite-adapter/src/index.ts:80-87`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (syncQueueService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Sync queue uses priority ordering: ORDER BY priority ASC (1=high), then created_at ASC (FIFO within priority)
- markFailed increments retry_count and checks against max_retries before marking as 'failed'
- Queue service follows standalone pattern (like SettingsSQLiteService) since it has different semantics than entity CRUD
- Added helper method `hasPending()` for quick check before triggering sync cycle

**Patterns to sync:**
- Pattern: Priority queue with FIFO ordering - use `ORDER BY priority ASC, created_at ASC` for priority-first then oldest-first

**Next story suggestion:** US-013 (Create DeviceSettingsSQLiteService) - depends on US-012 (just completed) and adds device-specific settings service.

---

## 2026-01-17 - US-013: Create DeviceSettingsSQLiteService
Commit: a417b05

**Why this story?** US-013 is the only story with all dependencies satisfied. It depends on US-012 (just completed in the previous iteration) and follows the same standalone service pattern for device-specific configuration storage.

**Changes:**
- `packages/sqlite-adapter/src/services/deviceSettingsService.ts` (NEW, 580 lines): Device settings service
  - `DeviceSettingsSQLiteService`: Standalone service for device-specific configuration
  - `get(deviceId)`: Retrieve settings for a specific device
  - `set(deviceId, settings)`: Upsert device settings using INSERT OR REPLACE
  - `delete(deviceId)`: Remove device settings
  - `getAll()`: Get all registered devices
  - `exists(deviceId)`: Check if device is registered
  - `register(deviceId, mode)`: Register a new device with defaults
  - `updateMode(deviceId, mode)`: Update device operating mode
  - `setOfflineModeEnabled(deviceId, enabled)`: Toggle offline mode
  - `recordSync(deviceId, timestamp?)`: Record last sync timestamp
  - `updateConfig(deviceId, config)`: Merge configuration updates
  - `getConfig(deviceId)`, `clearConfig(deviceId)`: Config accessors
  - `getByMode(mode)`: Query devices by mode
  - `getOfflineEnabled()`: Get devices with offline mode enabled
  - `getNotSyncedSince(since)`: Find devices that need sync
  - `count()`, `countByMode()`, `clear()`: Statistics and utilities
  - Types: `DeviceSettings`, `DeviceSettingsInput`, `DeviceConfig`, `DeviceMode`
- `packages/sqlite-adapter/src/services/index.ts:97-104`: Export DeviceSettingsSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:87-92`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (no errors in deviceSettingsService.ts; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _' in production code)

**Learnings:**
- DeviceSettings uses deviceId as PRIMARY KEY (not auto-generated id), matching Dexie schema
- DeviceConfig interface supports common POS peripherals: printer, cashDrawer, display, paymentTerminal, barcodeScanner
- `getNotSyncedSince()` uses `ORDER BY last_sync_at ASC NULLS FIRST` to prioritize devices that never synced
- Used `sqliteToBool() ?? false` pattern to handle undefined from integer columns with DEFAULT 0

**Patterns to sync:** None new - follows established standalone service pattern from SettingsSQLiteService

**Next story suggestion:** US-014 (Add migration v004 for infrastructure tables) - depends on US-013 (just completed) and creates the SQLite schema for settings, sync queue, and device settings tables.

---

## 2026-01-17 - US-014: Add migration v004 for infrastructure tables
Commit: 4fc6515

**Why this story?** US-014 is the only story with all dependencies satisfied. It depends on US-013 (just completed) and creates the SQLite migration for infrastructure tables (settings, syncQueue, deviceSettings) to match the services created in US-011, US-012, US-013.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v004_infrastructure.ts` (NEW, 137 lines): Infrastructure tables migration
  - `settings` table: Key-value store with `key TEXT PRIMARY KEY`, value as JSON TEXT
  - `sync_queue` table: Offline operation queue with priority (1-3), status tracking, retry support
    - Indexes: status, priority, status+created_at (compound), entity, priority+created_at (compound for efficient queue processing)
  - `device_settings` table: Device-specific config with `device_id TEXT PRIMARY KEY`
    - Includes mode, offline_mode_enabled, last_sync_at, registered_at, settings (JSON)
    - Indexes: mode, offline_mode_enabled
  - `down()` function removes indexes (preserves tables for safety)
- `packages/sqlite-adapter/src/migrations/index.ts:22`: Export migration_004

**Quality Checks:**
- Typecheck: PASS (no errors in v004_infrastructure.ts; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (console.log used for migration logging consistent with v001-v003)

**Learnings:**
- v003 migration already created these tables, but v004 adds additional indexes (priority+created_at compound index) and ensures complete schema
- Migration uses CREATE TABLE IF NOT EXISTS for idempotency - safe to run even if v003 already created tables
- down() only removes indexes, not tables, to preserve data during rollback
- Infrastructure tables use simpler schemas than entity tables (no storeId, no syncStatus)

**Patterns to sync:** None new - follows established migration patterns

**Next story suggestion:** US-015 (Wire infrastructure services to dataService) - depends on US-014 (just completed) and wires settings and syncQueue operations to SQLite.

---

## 2026-01-17 - US-015: Wire infrastructure services to dataService
Commit: a9f561e

**Why this story?** US-015 is the only story with all dependencies satisfied. It depends on US-014 (just completed) and wires the infrastructure services (settings, syncQueue) created in US-011 and US-012 to dataService for platform-aware routing.

**Changes:**
- `apps/store-app/src/services/sqliteServices.ts:33-34,55-56,547-714`:
  - Import SettingsSQLiteService and SyncQueueSQLiteService from @mango/sqlite-adapter
  - Add _settingsService and _syncQueueService lazy-initialized instances
  - `sqliteSettingsDB`: Wrapper with get<T>, set, remove methods matching Dexie settingsDB interface
  - `sqliteSyncQueueDB`: Wrapper with getAll, getPending, add, update, remove, clear methods
  - `SyncOperation` interface for dataService compatibility (uses Date for createdAt to match Dexie)
  - Status mapping: SQLite uses 'complete' while Dexie uses 'success' - handled in conversion
  - closeSQLite() updated to reset settings and syncQueue service instances
- `apps/store-app/src/services/dataService.ts:33,51-52,1494-1581,1625-1627`:
  - Import settingsDB from @/db/database
  - Import sqliteSettingsDB and sqliteSyncQueueDB from @/services/sqliteServices
  - `settingsService`: Routes get/set/remove to SQLite or Dexie based on USE_SQLITE flag
  - `syncQueueService`: Routes getAll/getPending/add/update/remove/clear with status mapping
  - update() maps 'success' status to 'complete' and 'error' to 'lastError' for SQLite compatibility
  - Export settings and syncQueue on dataService object

**Quality Checks:**
- Typecheck: PASS (no errors in dataService.ts or sqliteServices.ts; pre-existing errors in test files and api-client unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _' in production code)

**Learnings:**
- SyncOperation types differ between Dexie and SQLite: Dexie uses 'success' status, SQLite uses 'complete'
- Status mapping in update() prevents type errors when routing between backends
- SettingValue constraint (string|number|boolean|object|null) requires explicit casting in generic methods
- getPending() in SyncQueueSQLiteService takes no arguments; use getNext(limit) for limiting results

**Patterns to sync:** 
- Pattern #23: Status value mapping - when bridging between storage backends with different enum values (e.g., 'success' vs 'complete'), add explicit mapping in the routing layer rather than changing either backend.

**Next story suggestion:** US-016 (Create TeamMemberSQLiteService) - depends on US-015 (just completed) and is the first CRM/team service to implement.

---

## 2026-01-17 - US-016: Create TeamMemberSQLiteService
Commit: 2342b93

**Why this story?** US-016 is the only story with all dependencies satisfied. It depends on US-015 (just completed in the previous iteration) and follows the established BaseSQLiteService pattern for team member management with soft delete support.

**Changes:**
- `packages/sqlite-adapter/src/services/teamMemberService.ts` (NEW, 570 lines): Team member SQLite service
  - `TeamMemberSQLiteService`: Extends BaseSQLiteService<TeamMember, TeamMemberRow>
  - `getActive(storeId)`: Only active team members (is_deleted=0 AND is_active=1)
  - `getByRole(storeId, role)`: Filter by permissions.role using json_extract()
  - `getByStore(storeId, includeDeleted)`: All team members with optional deleted inclusion
  - `getManagers(storeId)`: Find owners and managers
  - `countByRole(storeId)`: SQL GROUP BY for role breakdown
  - `softDelete(id, userId?, deviceId?)`: Tombstone pattern with 30-day retention
  - `restore(id, userId?, deviceId?)`: Restore soft-deleted members
  - `cleanupExpiredTombstones(storeId)`: Hard delete expired tombstones
  - `activate(id)`, `deactivate(id)`: Toggle isActive without deleting
  - `getInactive(storeId)`: Get deactivated (not deleted) members
  - `getStatusCounts(storeId)`: Count active/inactive/deleted
  - `getByEmail(email)`: Profile email lookup using json_extract()
  - `getByEmployeeId(storeId, employeeId)`: Employee ID lookup
  - `search(storeId, query)`: Search by displayName/firstName/lastName
  - `updateProfile(id, profile)`: Update profile JSON
  - `updatePermissions(id, permissions)`: Update permissions JSON
  - `updateRole(id, role)`: Update role specifically
  - `getPendingSync(storeId)`: Get members needing sync
  - `getUpdatedSince(storeId, since)`: Recent changes
  - `markSynced(id, syncedVersion)`: Mark as synced
  - `countActive(storeId)`, `countByStore(storeId)`: Count queries
  - Types: TeamMember, TeamMemberRow, TeamMemberProfile, TeamMemberPermissions, TeamMemberRole, TeamMemberSyncStatus, VectorClock
- `packages/sqlite-adapter/src/services/index.ts:106-116`: Export TeamMemberSQLiteService and all types
- `packages/sqlite-adapter/src/index.ts:93-101`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (no errors in teamMemberService.ts; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _', 'console.log')

**Learnings:**
- TeamMember entity extends BaseSyncableEntity pattern from the app types (includes vectorClock, tombstoneExpiresAt for proper sync support)
- Profile and permissions are stored as JSON TEXT columns with json_extract() for querying nested fields
- Soft delete sets both isDeleted=true AND isActive=false to ensure the member doesn't appear in any active queries
- VectorClock type is Record<string, number> matching the app's conflict detection pattern

**Patterns to sync:** None new - follows established BaseSQLiteService and soft delete patterns

**Next story suggestion:** US-017 (Create CRM SQLite services batch) - depends on US-016 (just completed) and creates 8 CRM-related services in a single file.

---

## 2026-01-17 - US-017: Create CRM SQLite services (batch)
Commit: 8e9c99c

**Why this story?** US-017 is the only story with all dependencies satisfied. It depends on US-016 (just completed) and follows the established BaseSQLiteService pattern for CRM-related tables.

**Changes:**
- `packages/sqlite-adapter/src/services/crmServices.ts` (NEW, 890 lines): 8 CRM SQLite services in single file
  - `PatchTestSQLiteService`: Allergy/sensitivity test records (PRD 2.3.3)
    - `getByClient(clientId)`: Get tests for a client
    - `getExpiring(withinDays)`: Get tests expiring soon
    - `getByClientAndService(clientId, serviceId)`: Get specific test
    - `hasValidPatchTest(clientId, serviceId)`: Check valid non-expired pass
    - `getExpired()`: Get all expired tests for cleanup
  - `FormTemplateSQLiteService`: Consultation form templates (PRD 2.3.4)
    - `getActive(storeId)`: Active templates
    - `getByStore(storeId)`: All templates by store
    - `getByLinkedService(storeId, serviceId)`: Templates linked to service using json_each()
    - `getAutomatic(storeId)`: Auto-send templates
  - `FormResponseSQLiteService`: Client form submissions (PRD 2.3.4)
    - `getByClient(clientId)`: Responses by client
    - `getByAppointment(appointmentId)`: Responses by appointment
    - `getPendingByClient(clientId)`: Pending responses
    - `getByTemplate(templateId)`: Responses by template
    - `getCompletedInRange(storeId, start, end)`: Completed in date range
    - `complete(id, completedBy)`: Mark response complete
  - `ReferralSQLiteService`: Client referral tracking (PRD 2.3.8)
    - `getByReferrer(referrerClientId)`: Referrals made by a client
    - `getByCode(referralLinkCode)`: Get by referral code
    - `getReferralCount(referrerClientId)`: Count referrals
    - `getSuccessfulByReferrer(referrerClientId)`: Completed referrals
    - `getPendingRewards()`: Referrals needing reward issuance
    - `markReferrerRewardIssued(id)`, `markReferredRewardIssued(id)`: Mark rewards issued
  - `ClientReviewSQLiteService`: Client reviews and ratings (PRD 2.3.9)
    - `getByClient(clientId)`: Reviews by client
    - `getByStaff(staffId)`: Reviews by staff
    - `getAverageRating(staffId)`: SQL AVG for staff rating
    - `getStoreAverageRating(storeId)`: SQL AVG/COUNT for store
    - `getByRatingRange(storeId, min, max)`: Filter by rating
    - `getNeedingResponse(storeId)`: Reviews without response
    - `addResponse(id, response)`: Add staff response
  - `LoyaltyRewardSQLiteService`: Loyalty program rewards (PRD 2.3.7)
    - `getByClient(clientId)`: Rewards by client
    - `getAvailable(clientId)`: Unredeemed, non-expired rewards
    - `getByStore(storeId)`: Rewards by store
    - `getByType(storeId, type)`: Filter by reward type
    - `getExpiringSoon(storeId, withinDays)`: Rewards expiring soon
    - `redeem(id)`: Mark reward redeemed
    - `countAvailable(clientId)`: Count available rewards
  - `ReviewRequestSQLiteService`: Review invitation tracking (PRD 2.3.9)
    - `getByStatus(storeId, status)`: Filter by status
    - `getPending(storeId)`: Pending requests
    - `getByClient(clientId)`: Requests by client
    - `getByStore(storeId)`: Requests by store
    - `getNeedingReminder(storeId, maxReminders)`: Requests needing reminder
    - `getExpired(storeId)`: Expired requests
    - `markSent(id)`, `markOpened(id)`, `markCompleted(id, reviewId)`: Status updates
    - `incrementReminderCount(id)`: Increment reminder count
  - `CustomSegmentSQLiteService`: Custom client segmentation (PRD 2.3.10)
    - `getActive(storeId)`: Active segments
    - `getByStore(storeId)`: All segments by store
    - `getByName(storeId, name)`: Uniqueness check
    - `activate(id)`, `deactivate(id)`: Toggle segment active status
    - `countActive(storeId)`: Count active segments
- `packages/sqlite-adapter/src/services/index.ts:109-148`: Export all 8 CRM services and types
- `packages/sqlite-adapter/src/index.ts:102-140`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (no errors in crmServices.ts; pre-existing errors in factory.ts/adapters unrelated)
- Tests: Not run (no test file created for this batch - follows existing pattern of no tests for service files)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _', 'console.log')

**Learnings:**
- All 8 CRM services follow the same BaseSQLiteService pattern established in earlier stories
- FormTemplateSQLiteService.getByLinkedService uses json_each() to search within linkedServiceIds JSON array
- ClientReviewSQLiteService.getAverageRating uses SQL AVG() function directly - efficient aggregation
- LoyaltyReward and ReviewRequest services have expiration-based queries that filter on expires_at timestamps
- CustomSegment filters use nested SegmentFilterGroup interface for AND/OR logic

**Patterns to sync:** None new - follows established BaseSQLiteService pattern for batch service creation

**Next story suggestion:** US-018 (Add migration v005 for team and CRM tables) - depends on US-017 (just completed) and creates the SQLite schema for all these CRM services.

---

## 2026-01-17 - US-018: Add migration v005 for team and CRM tables
Commit: 9d8c5b9

**Why this story?** US-018 is the only story with all dependencies satisfied. It depends on US-017 (just completed) and creates the SQLite schema for all team and CRM services created in US-016 and US-017.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v005_team_crm.ts` (NEW, 596 lines): Team and CRM tables migration
  - `team_members` table: Full team member management with soft delete pattern
    - id, tenant_id, store_id, location_id as identifiers
    - profile (JSON TEXT), permissions (JSON TEXT) for nested data
    - is_active (INTEGER), is_deleted (INTEGER) for status
    - Sync metadata: sync_status, version, vector_clock, last_synced_version
    - Tombstone support: tombstone_expires_at for soft delete expiration
    - Full audit trail: created_at, updated_at, created_by, created_by_device, last_modified_by, last_modified_by_device
    - Indexes: store, store+active, store+deleted, store+sync, created, updated
  - `timesheets` table: Staff time tracking (Phase 2)
    - Time tracking: clock_in, clock_out, break_start, break_end, break_duration_minutes
    - Calculated: total_hours, overtime_hours
    - Status/approval: status, approved_by, approved_at
    - Indexes: store+date, staff+date, store+staff, store+status, store+sync
  - `pay_runs` table: Payroll processing (Phase 3)
    - Pay period: period_start, period_end
    - Status, totals (gross, deductions, net), entries (JSON)
    - Indexes: store+period, store+status, store+sync
  - `patch_tests` table: Allergy/sensitivity test records (PRD 2.3.3)
    - client_id, service_id, test_date, result, expires_at
    - Indexes: client, client+service, client+expires, store
  - `form_templates` table: Consultation form templates (PRD 2.3.4)
    - name, fields (JSON), is_active, is_required, auto_send_enabled
    - linked_service_ids (JSON array) for service associations
    - Indexes: store, store+active
  - `form_responses` table: Client form submissions (PRD 2.3.4)
    - form_template_id, client_id, appointment_id
    - responses (JSON), status, completed_at, completed_by
    - Indexes: client, client+status, client+completed, template, appointment
  - `referrals` table: Client referral tracking (PRD 2.3.8)
    - referrer_client_id, referred_client_id, referral_link_code
    - Reward tracking: referrer_reward_issued, referred_reward_issued with timestamps
    - Conversion: converted_at, first_purchase_at, first_purchase_amount
    - Indexes: referrer, referrer+created, code, store, status
  - `client_reviews` table: Reviews and ratings (PRD 2.3.9)
    - client_id, appointment_id, staff_id, rating, review_text, platform
    - Staff response: response_text, response_by, response_at
    - Display: is_visible, is_featured
    - Indexes: client, client+created, staff, staff+rating, store, store+rating
  - `loyalty_rewards` table: Loyalty program rewards (PRD 2.3.7)
    - type, name, description, value, code, expires_at
    - Redemption: redeemed_at, redeemed_ticket_id
    - Source: earned_from, earned_at, points_cost
    - Indexes: client, client+redeemed, store, store+type, store+expires
  - `review_requests` table: Review invitation tracking (PRD 2.3.9)
    - client_id, appointment_id, staff_id, ticket_id
    - Sending: sent_at, sent_via
    - Tracking: opened_at, completed_at, review_id
    - Reminder: reminder_count, last_reminder_at, expires_at
    - Indexes: store, store+status, client, client+status, store+created, staff+created
  - `custom_segments` table: Custom client segmentation (PRD 2.3.10)
    - name, description, filters (JSON), is_active
    - Caching: cached_count, last_calculated_at
    - Display: color, icon
    - Indexes: store, store+active, store+created
  - `down()` function drops all indexes and tables in reverse order
- `packages/sqlite-adapter/src/migrations/index.ts:23`: Export migration_005

**Quality Checks:**
- Typecheck: PASS (v005_team_crm.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (console.log used for migration logging consistent with v001-v004)

**Learnings:**
- Migration creates 11 tables total: 3 team tables (team_members, timesheets, pay_runs) + 8 CRM tables
- Team members table uses snake_case columns (tenant_id, store_id) matching other SQLite tables
- JSON columns (profile, permissions, filters, responses) store complex nested objects as TEXT
- Soft delete pattern uses is_deleted column with tombstone_expires_at for cleanup scheduling
- All CRM tables include store_id index for multi-tenant queries

**Patterns to sync:** None new - follows established migration patterns from v001-v004

**Next story suggestion:** US-019 (Wire team/CRM services to dataService) - depends on US-018 (just completed) and wires all team/CRM services to the dataService routing layer.

---

## 2026-01-17 - US-019: Wire team/CRM services to dataService
Commit: 676fadc

**Why this story?** US-019 is the only story with all dependencies satisfied. It depends on US-018 (just completed) and wires all team/CRM SQLite services to dataService for SQLite routing.

**Changes:**
- `apps/store-app/src/services/sqliteServices.ts:1-60`: Added CRM service imports
  - Import TeamMemberSQLiteService and all 8 CRM service classes from @mango/sqlite-adapter
  - Import app types for CRM entities (PatchTest, FormResponse, Referral, ClientReview, LoyaltyReward, ReviewRequest, CustomSegment)
  - Added lazy-initialized service instance variables for all 9 services
- `apps/store-app/src/services/sqliteServices.ts:780-1320`: Added SQLite service wrappers
  - `sqliteTeamMemberDB`: Team member operations with role-based filtering, getAll(), getById(), getByRole()
  - `sqlitePatchTestsDB`: Patch test CRUD with getValidForService(), getExpiring()
  - `sqliteFormResponsesDB`: Form response operations with complete() method, pending filtering
  - `sqliteReferralsDB`: Referral tracking with getByReferrerId(), getByCode(), completeReferral()
  - `sqliteClientReviewsDB`: Client reviews with addResponse() for staff replies
  - `sqliteLoyaltyRewardsDB`: Loyalty rewards with getAvailable(), redeem()
  - `sqliteReviewRequestsDB`: Review request lifecycle (markSent, markOpened, markCompleted, markExpired)
  - `sqliteCustomSegmentsDB`: Custom segments with activate(), deactivate(), duplicate()
- `apps/store-app/src/services/sqliteServices.ts:closeSQLite()`: Reset all service instances on close
- `apps/store-app/src/services/dataService.ts:51-60`: Added imports for all 9 SQLite service wrappers
- `apps/store-app/src/services/dataService.ts:1131-1789`: Updated all CRM services with USE_SQLITE routing
  - `patchTestsService`: Routes getByClientId, getById, getValidForService, getExpiring, create, update, delete to SQLite
  - `formResponsesService`: Routes getByClientId, getById, getPending, getByAppointmentId, create, update, complete to SQLite
  - `referralsService`: Routes getByReferrerId, getByReferredId, getById, getByCode, create, update, completeReferral to SQLite
  - `reviewsService`: Routes getByClientId, getById, getByStaffId, create, addResponse, update to SQLite
  - `loyaltyService`: Routes getByClientId, getById, getAvailable, create, redeem to SQLite
  - `reviewRequestsService`: Routes getById, getByClientId, getBySalonId, getByStatus, getPendingByClient, create, update, markSent, markOpened, markCompleted, markExpired, delete to SQLite
  - `segmentsService`: Routes getById, getAll, getActive, getByName, create, update, updateFilters, activate, deactivate, delete, duplicate to SQLite
- `apps/store-app/src/services/dataService.ts:1747-1787`: Added teamMembersService with SQLite routing
  - getAll(storeId), getById(id), getByRole(storeId, role)
  - Falls back to staffService for non-SQLite mode
- `apps/store-app/src/services/dataService.ts:1930`: Exported teamMembers in dataService object

**Quality Checks:**
- Typecheck: PASS (no errors in dataService.ts or sqliteServices.ts; pre-existing test file errors unrelated)
- ESLint: PASS (only pre-existing warnings about trivially inferrable types and unused parameters)
- Tests: PASS (sqlite-adapter tests pass; monorepo test config has pre-existing watch mode issues)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Each CRM dataService method needs USE_SQLITE check at start to route to SQLite or Dexie
- TeamMembersService is SQLite-only (created in US-016), but falls back to staffService for non-SQLite mode
- All SQLite wrappers use `as unknown as AppType` for type compatibility between SQLite and app types
- closeSQLite() must reset all service instance variables to ensure clean re-initialization

**Patterns to sync:** None new - follows established dataService routing pattern from US-015

**Next story suggestion:** US-020 (Create Catalog SQLite services) - depends on US-019 and creates SQLite services for service catalog tables (categories, add-ons, variants).

---

## 2026-01-17 - US-020: Create Catalog SQLite services
Commit: 608dec7

**Why this story?** US-020 is the only story with all dependencies satisfied. It depends on US-019 (just completed) and creates 9 catalog-related SQLite services for service menu management.

**Changes:**
- `packages/sqlite-adapter/src/services/catalogServices.ts` (NEW, 1380 lines): 9 catalog SQLite services
  - `ServiceCategorySQLiteService`: Categories with getActive(), getByParent(), getRootCategories(), getChildCategories(), updateDisplayOrder()
  - `MenuServiceSQLiteService`: Services with getByCategory(), getActive(), search(), getOnlineBookingEnabled(), countByCategory(), getRequiringPatchTest(), updateDisplayOrder()
  - `ServiceVariantSQLiteService` (renamed to CatalogServiceVariant to avoid conflicts): Variants with getByService(), getActiveByService(), getDefaultByService(), setDefault()
  - `ServicePackageSQLiteService`: Packages with getActive(), getOnlineBookingEnabled(), search()
  - `AddOnGroupSQLiteService`: Add-on groups with getApplicableToService(), getApplicableToCategory() using json_each()
  - `AddOnOptionSQLiteService`: Add-on options with getByGroup(), getActiveByGroup(), deleteByGroup()
  - `StaffServiceAssignmentSQLiteService`: Assignments with getByStaff(), getByService(), getByStaffAndService(), bulkAssignToStaff(), removeAllForStaff()
  - `CatalogSettingsSQLiteService`: Settings with get(), set(), getOrCreate() for store config
  - `ProductSQLiteService`: Products with getByCategory(), search(), getBySku(), getByBarcode(), getRetail(), getBackbar(), getBySupplier(), getCategories(), countByCategory()
- `packages/sqlite-adapter/src/services/index.ts:150-189`: Export all 9 catalog services and types
- `packages/sqlite-adapter/src/index.ts:141-179`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (catalogServices.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (pre-existing failures in supabase and other packages with no test files - not related to changes)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Renamed ServiceVariant to CatalogServiceVariant to avoid conflict with existing ServiceVariant export from serviceService.ts
- All services use async/await with this.db.all(), this.db.run(), this.db.get() methods (not synchronous prepare())
- AddOnGroup services use json_each() for querying within JSON array columns (applicable_service_ids, applicable_category_ids)
- Product service includes barcode lookup for POS scanning integration

**Patterns to sync:** None new - follows established BaseSQLiteService pattern

**Next story suggestion:** US-021 (Add migration v006 for catalog tables) - depends on US-020 (just completed) and creates the SQLite schema for all catalog services.

---

## 2026-01-17 - US-021: Add migration v006 for catalog tables
Commit: fe1c3e6

**Why this story?** US-021 is the only story with all dependencies satisfied. It depends on US-020 (just completed) and creates the SQLite schema (migration) for the 9 catalog services created in the previous story.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v006_catalog.ts` (NEW, 510 lines): Catalog tables migration
  - `service_categories`: Hierarchical categories with parent_category_id, display_order, show_online_booking
  - `menu_services`: Full service menu with 30+ columns (pricing, duration, online booking, deposits, turn tracking)
  - `service_variants`: Service variations with duration, price, is_default flag
  - `service_packages`: Bundle offerings with services JSON, discount, booking_mode, validity
  - `add_on_groups`: Optional add-ons with selection rules (min/max selections, applicable_to_all)
  - `add_on_options`: Individual add-on items with price, duration
  - `staff_service_assignments`: Staff-service mapping with custom_price, custom_duration, custom_commission
  - `catalog_settings`: Per-store config for defaults, currency, feature toggles
  - `products`: Retail/backbar inventory with SKU, barcode, pricing, supplier info
  - Comprehensive indexes for filtering queries (store_id, is_active, display_order, etc.)
  - `down()` function for clean rollback (drops indexes then tables)
- `packages/sqlite-adapter/src/migrations/index.ts:23`: Export migration_006

**Quality Checks:**
- Typecheck: PASS (migration files compile without errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests in sqlite-adapter package all passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Catalog tables have many JSON columns for nested data (services array in packages, applicable_*_ids in add-on groups)
- Products table needs unique index on (store_id, sku) for SKU lookup
- Barcode index should be on barcode column alone (not compound) for quick scanner lookup across stores

**Patterns to sync:** None new - follows established migration patterns from v005

**Next story suggestion:** US-022 (Create Scheduling SQLite services) - depends on US-021 (just completed) and creates 8 scheduling-related services.

---
