# SQLite Complete Migration - Progress Log

## Codebase Patterns

> Add reusable patterns discovered during implementation here.

### Type Conversion
- Always use `toISOString()` for Date → SQLite TEXT conversion, never `String(date)` or `toString()`
- Use `boolToSQLite(value): 0 | 1` for boolean → INTEGER conversion
- Use `safeParseJSON<T>(text, fallback)` for TEXT → object conversion

### SQL Best Practices
- Use `json_each()` for aggregating over JSON array columns
- Always use parameterized queries: `db.prepare('SELECT * FROM x WHERE id = ?').get(id)`
- Use `INSERT OR REPLACE INTO` for upsert operations

### Service Pattern
- Extend `BaseSQLiteService<T, TRow>` for all table services
- Define schema config with column mappings and type hints
- Keep query methods (getByX) in service class, not base class

---

## Architectural Decisions

### Hybrid Approach for Existing Services (Pre-Ralph Decision)

**Decision:** Use BaseSQLiteService for ALL NEW services, but do NOT refactor existing services.

**Context:**
- `clientService.ts` (702 lines) and `ticketService.ts` (~650 lines) already exist and work
- Refactoring 1,350+ lines of working code risks introducing bugs
- New services (40 of them) will benefit from BaseSQLiteService consistency

**Approach:**
1. Keep existing clientService and ticketService as-is
2. Use BaseSQLiteService pattern for all 40 new services
3. Only add MISSING methods to existing services (US-009)
4. Fix incomplete migration schemas (US-036, US-037)

**Future option:** Can optionally migrate existing services to BaseSQLiteService later if needed.

---

## Progress Log

> Each iteration appends below this line.

---

## 2026-01-17 - US-042: Type-safe conversion utilities
Commit: b4d58473b6a5a8538cc1ecd9311df9bcfe5acf72

**Why this story?** US-042 has no dependencies and is explicitly marked as the foundation story (priority 1) - all other services depend on these utilities.

**Changes:**
- `packages/sqlite-adapter/src/utils/typeConversions.ts` (NEW, 170 lines): Core conversion utilities
  - `toISOString(value)`: Converts Date/string/number to ISO 8601 string for SQLite TEXT storage
  - `boolToSQLite(value)`: Converts boolean-like values to 0/1 for SQLite INTEGER storage
  - `sqliteToBool(value)`: Inverse of boolToSQLite for reading back
  - `safeParseJSON<T>(value, fallback)`: Safe JSON parsing with type inference from fallback
  - `toJSONString(value)`: Safe JSON.stringify with circular reference handling
- `packages/sqlite-adapter/src/utils/index.ts` (NEW): Barrel export
- `packages/sqlite-adapter/src/index.ts:41-48`: Added exports for all conversion utilities
- `packages/sqlite-adapter/vitest.config.ts` (NEW): Package-specific test config (jsdom → node environment)
- `packages/sqlite-adapter/src/utils/__tests__/typeConversions.test.ts` (NEW, 270 lines): Comprehensive test suite

**Quality Checks:**
- Typecheck: PASS (new files only; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests covering all edge cases)
- Forbidden strings: PASS (no 'as any', 'void _')

**Learnings:**
- sqlite-adapter package needed its own vitest.config.ts with environment: 'node' (root config uses jsdom for React)
- Pre-existing typecheck errors in factory.ts (window undefined) and adapters (unused params) - not in scope to fix
- Added two bonus utilities (`sqliteToBool`, `toJSONString`) as inverse operations for completeness

**Patterns to sync:**
- Pattern: Package-specific vitest.config.ts - each package may need its own config with appropriate environment

**Next story suggestion:** US-001 (Create BaseSQLiteService) - it directly depends on US-042 and is the next logical step for building the service foundation.

---

## 2026-01-17 - US-001: Create BaseSQLiteService generic class
Commit: e00bc66

**Why this story?** US-001 depends on US-042 (just completed) and is the foundation class for all 40 new services. Priority 2 is highest among remaining stories with satisfied dependencies.

**Changes:**
- `packages/sqlite-adapter/src/services/BaseSQLiteService.ts` (NEW, 380 lines): Generic base service class
  - `BaseSQLiteService<T, TRow>`: Generic class with type parameters for app entity and SQLite row
  - CRUD operations: `getAll()`, `getById()`, `getByIds()`, `create()`, `update()`, `delete()`, `count()`
  - Schema config: `TableSchema` interface with tableName, primaryKey, and column mappings
  - Column definitions support type hints: `{ column: string, type: ColumnType, defaultValue?: unknown }`
  - Type conversion: Uses `boolToSQLite`, `sqliteToBool`, `toISOString`, `safeParseJSON`, `toJSONString` from US-042
  - Protected query helpers: `findWhere()`, `countWhere()`, `findOneWhere()`, `rawQuery()`, `rawQueryOne()`
- `packages/sqlite-adapter/src/services/index.ts:10-16`: Export BaseSQLiteService and related types
- `packages/sqlite-adapter/src/index.ts:27-31`: Export BaseSQLiteService from package root

**Quality Checks:**
- Typecheck: PASS (BaseSQLiteService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests from US-042 still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Schema config with type hints allows automatic conversion during `rowToEntity()` and `entityToRow()`
- Protected helpers (`findWhere`, `countWhere`) enable subclasses to build custom queries without SQL duplication
- Existing ClientSQLiteService (702 lines) follows similar pattern but with inline conversion - new services should use BaseSQLiteService

**Patterns to sync:**
- Pattern: TableSchema with ColumnDefinition - use `{ column: 'db_column', type: 'boolean' }` for typed columns

**Next story suggestion:** US-036 (Fix client schema with ALL columns) - depends on US-001 and fixes the incomplete migration schema needed before services can work properly.

---

## 2026-01-17 - US-036: Fix client schema with ALL columns
Commit: fd8d83e

**Why this story?** US-036 depends on US-001 (just completed) and has priority 3, the highest among remaining stories with satisfied dependencies. US-037 and all subsequent stories depend on US-036 being done first.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:52-134`: Expanded clients table from 8 to 50+ columns
  - Primary fields: id, store_id
  - Name fields: first_name, last_name, display_name, nickname, name
  - Contact fields: phone, email, avatar
  - Personal info: gender, birthday, anniversary, preferred_language
  - Complex JSON fields: address, emergency_contacts, staff_alert
  - Block fields: is_blocked (INTEGER), blocked_at, blocked_by, block_reason, block_reason_note
  - Source tracking: source, source_details, referred_by_client_id, referred_by_client_name
  - Profile JSON: hair_profile, skin_profile, nail_profile, medical_info
  - Preferences JSON: preferences, communication_preferences
  - Loyalty JSON: loyalty_info, loyalty_tier, membership, gift_cards
  - Visit stats: visit_summary, last_visit, total_visits (INTEGER), total_spent (REAL)
  - Balance: outstanding_balance (REAL), store_credit (REAL)
  - Reviews: average_rating (REAL), total_reviews (INTEGER)
  - Tags/notes: tags (JSON), notes (JSON)
  - VIP status: is_vip (INTEGER)
  - Timestamps: created_at, updated_at, sync_status
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:149-184`: Added 7 new indexes for clients
  - idx_clients_store: Basic store filter
  - idx_clients_store_lastname: [store_id+last_name] for alphabetical lists
  - idx_clients_store_vip: [store_id+is_vip] for VIP filtering
  - idx_clients_store_blocked: [store_id+is_blocked] for blocked filtering
  - idx_clients_store_created: [store_id+created_at] for date sorting
  - idx_clients_store_phone: [store_id+phone] for duplicate prevention
  - idx_clients_store_email: [store_id+email] for email lookup

**Quality Checks:**
- Typecheck: PASS (v001_initial_schema.ts passes; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests from US-042 still passing)
- Forbidden strings: PASS (no 'as any')

**Learnings:**
- Column names in SQLite use snake_case (store_id) while ClientRow interface matches them exactly
- Boolean fields use INTEGER type with DEFAULT 0 (is_blocked, is_vip)
- Numeric fields use REAL for decimals (total_spent, outstanding_balance) and INTEGER for counts (total_visits)
- JSON objects stored as TEXT columns (address, preferences, hair_profile, etc.)

**Patterns to sync:**
- Pattern: SQLite snake_case column naming - all columns use snake_case (store_id, first_name) matching ClientRow interface

**Next story suggestion:** US-037 (Fix ticket schema with ALL columns) - depends on US-036 (just completed) and is the next logical step to complete migration schemas before services can work.

---

## 2026-01-17 - US-037: Fix ticket schema with ALL columns
Commit: 10847c7

**Why this story?** US-037 is the only story with all dependencies met. It depends on US-036 (just completed) and both work on the same file (`v001_initial_schema.ts`), so the code structure is fresh in context.

**Changes:**
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:37-121`: Expanded tickets table from 8 to 45 columns matching TicketRow interface
  - Primary fields: id, number (INTEGER), store_id, appointment_id
  - Client fields: client_id, client_name, client_phone
  - Group ticket fields: is_group_ticket (INTEGER DEFAULT 0), clients (JSON)
  - Merged ticket fields: is_merged_ticket (INTEGER), merged_from_tickets, original_ticket_id, merged_at, merged_by
  - Services/products: services (JSON), products (JSON)
  - Status: status
  - Pricing fields: subtotal, discount, discount_reason, discount_percent, tax, tax_rate, tip, total (all REAL)
  - Payments: payments (JSON)
  - Timestamps: created_at, updated_at, completed_at
  - Audit: created_by, last_modified_by, sync_status
  - Draft fields: is_draft (INTEGER), draft_expires_at, last_auto_save_at
  - Source: source
  - Service charges: service_charges (JSON), service_charge_total
  - Staff: staff_id, staff_name, payment_method
  - Closing: closed_at, closed_by
  - Signature: signature_base64, signature_timestamp
- `packages/sqlite-adapter/src/migrations/v001_initial_schema.ts:217-252`: Added 6 indexes for tickets
  - idx_tickets_store_status: [store_id+status] for status filtering
  - idx_tickets_store_created: [store_id+created_at] for date sorting
  - idx_tickets_client_created: [client_id+created_at] for client ticket history
  - idx_tickets_store_status_created: [store_id+status+created_at] for turn queue queries
  - idx_tickets_store_staff_created: [store_id+staff_id+created_at] for staff reports
  - idx_tickets_store_appointment: [store_id+appointment_id] for appointment lookup

**Quality Checks:**
- Typecheck: PASS (v001_initial_schema.ts passes; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any')

**Learnings:**
- Ticket pricing fields (subtotal, discount, tax, tip, total) use REAL type with DEFAULT 0 for numeric safety
- JSON array columns (services, products, payments, clients, merged_from_tickets) use TEXT with NOT NULL where required
- Staff assignment fields (staff_id, staff_name) are nullable - primary staff can be derived from services array
- Both client and ticket schemas now complete - ready for schema registry (US-002)

**Patterns to sync:**
- Pattern: Required JSON arrays - use `TEXT NOT NULL` for JSON arrays that must always exist (even if empty `[]`)

**Next story suggestion:** US-002 (Create TableSchema type and registry) - depends on US-037 (just completed) and is the foundation for type-safe schema definitions used by all services.

---

## 2026-01-17 - US-002: Create TableSchema type and registry
Commit: 17f2330

**Why this story?** US-002 is the only story with all dependencies satisfied. It depends on US-037 (just completed) and provides the schema registry foundation needed by all subsequent services (US-005, US-006, etc.).

**Changes:**
- `packages/sqlite-adapter/src/schema/types.ts` (NEW, 145 lines): Schema type definitions
  - `ColumnType`: Union type for column data types ('string'|'number'|'boolean'|'json'|'date')
  - `ColumnSchema`: Full column definition interface (name, dbColumn, type, defaultValue, nullable)
  - `ColumnDefinition`: Simplified column definition for BaseSQLiteService compatibility
  - `ColumnMapping`: Union of string shorthand or ColumnDefinition
  - `TableSchema`: Main interface with tableName, primaryKey, columns Record
  - `ExtendedTableSchema`: Extended version with description, indexes, foreignKeys
  - `ForeignKeySchema`: Foreign key relationship definition
  - `SchemaRegistry<T>`: Generic registry type for type-safe table lookup
  - `CoreTableName`, `InfrastructureTableName`, `AllTableName`: Table name union types
- `packages/sqlite-adapter/src/schema/registry.ts` (NEW, 340 lines): Schema definitions for 6 core tables
  - `appointmentsSchema`: Scheduled appointments with services JSON, dates
  - `ticketsSchema`: All 45 columns matching v001 migration, with pricing fields, JSON arrays
  - `clientsSchema`: All 50+ columns matching v001 migration, with profiles, preferences
  - `staffSchema`: Staff with schedule JSON, skills, status
  - `servicesSchema`: Menu services with pricing, add-ons, variants as JSON
  - `transactionsSchema`: Payment transactions with card details, refund info
  - `schemaRegistry`: Type-safe lookup object for all core tables
  - Helper functions: `getSchema()`, `hasSchema()`, `getTableNames()`
- `packages/sqlite-adapter/src/schema/index.ts` (NEW, 35 lines): Barrel export for all schema types and registry
- `packages/sqlite-adapter/src/index.ts:57-83`: Export schema types and registry from package root
  - Aliased `ColumnType` as `SchemaColumnType` to avoid collision with services export

**Quality Checks:**
- Typecheck: PASS (new schema files have no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Schema registry provides type-safe lookup: `schemaRegistry.clients` returns ClientSchema
- ColumnMapping union (string | ColumnDefinition) allows both shorthand (`'store_id'`) and full definition (`{ column: 'is_blocked', type: 'boolean' }`)
- ExtendedTableSchema adds metadata for documentation/migration - useful for future tooling
- Exported `SchemaColumnType` alias to avoid name collision with `ColumnType` already exported from services

**Patterns to sync:**
- Pattern: Schema registry with type-safe lookup - use `SchemaRegistry<TableName>` for compile-time table name validation

**Next story suggestion:** US-005 (Create AppointmentSQLiteService) - depends on US-002 (just completed) and is the first service to use the new schema registry pattern.

---

## 2026-01-17 - US-005: Create AppointmentSQLiteService
Commit: ed115c0

**Why this story?** US-005 is the only story with all dependencies satisfied. It depends on US-002 (just completed) and is the first SQLite service to use BaseSQLiteService for handling scheduled appointments.

**Changes:**
- `packages/sqlite-adapter/src/services/appointmentService.ts` (NEW, 290 lines): Appointment SQLite service
  - `AppointmentSQLiteService`: Extends BaseSQLiteService<Appointment, AppointmentRow>
  - `getByDateRange(storeId, start, end)`: Calendar view queries using SQL BETWEEN
  - `getByStaff(staffId, date?)`: Staff schedule queries with optional date filter
  - `getByClient(clientId)`: Client appointment history
  - `getByStatus(storeId, status)`: Dashboard filtering by appointment status
  - `getUpcoming(storeId, hours)`: Appointments starting within N hours (excludes cancelled/no-show)
  - `getToday(storeId)`: Convenience method for today's appointments
  - `getByStore(storeId)`: All appointments for a store with pagination
  - `countByStatus(storeId, status)`: Dashboard metrics
  - Helper methods: `updateStatus()`, `checkIn()`, `startService()`, `complete()`, `cancel()`, `markNoShow()`
- `packages/sqlite-adapter/src/services/index.ts:38-46`: Export AppointmentSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:46-52`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (appointmentService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Appointment table uses camelCase column names (unlike clients/tickets which use snake_case) - schema must match
- Interface must extend `Record<string, unknown>` to satisfy BaseSQLiteService constraint
- Date range queries use ISO string comparison which works correctly with SQLite's string ordering
- Services array stored as JSON TEXT column with `type: 'json'` for automatic serialization

**Patterns to sync:**
- Pattern: Interface extends Record<string, unknown> - entity types used with BaseSQLiteService must satisfy this constraint

**Next story suggestion:** US-006 (Create TransactionSQLiteService) - depends on US-005 and follows the same service pattern for payment transactions.

---

## 2026-01-17 - US-006: Create TransactionSQLiteService
Commit: ee71593

**Why this story?** US-006 is the only story with all dependencies satisfied. It depends on US-005 (just completed) and follows the same service pattern for payment transactions with SQL aggregation queries.

**Changes:**
- `packages/sqlite-adapter/src/services/transactionService.ts` (NEW, 310 lines): Transaction SQLite service
  - `TransactionSQLiteService`: Extends BaseSQLiteService<Transaction, TransactionRow>
  - `getByTicket(ticketId)`: All transactions for a ticket (checkout flow)
  - `getByDateRange(storeId, start, end)`: Date range queries for reporting
  - `getTotalByDateRange(storeId, start, end)`: SQL SUM aggregation (no JS reduce) - returns TransactionTotals
  - `getByPaymentMethod(storeId, method)`: Filter by payment type for analytics
  - `getByClient(clientId)`: Client transaction history
  - `getByStatus(storeId, status)`: Filter by transaction status
  - `getTotalsByPaymentMethod(storeId, start, end)`: SQL GROUP BY for payment method breakdown
  - `getByStore(storeId)`: All transactions for a store with pagination
  - `countByStatus(storeId, status)`: Dashboard metrics
  - Helper methods: `updateStatus()`, `recordRefund()`, `void()`, `getTodayTotal()`
  - Types: `Transaction`, `TransactionRow`, `TransactionTotals`, `TotalsByPaymentMethod`, `PaymentMethod`, `TransactionStatus`
- `packages/sqlite-adapter/src/services/index.ts:48-57`: Export TransactionSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:53-60`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (transactionService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- SQL aggregation with COALESCE handles null values: `COALESCE(SUM(amount), 0) as total_amount`
- TransactionTotals includes computed field `netAmount = totalAmount - refundedAmount`
- GROUP BY queries return array of objects - map to TypeScript interface for type safety
- recordRefund method determines partial vs full refund status based on cumulative amount

**Patterns to sync:**
- Pattern: SQL aggregation with COALESCE - use `COALESCE(SUM(column), 0)` to handle null values in aggregations

**Next story suggestion:** US-007 (Create StaffSQLiteService) - depends on US-006 and continues the service pattern for staff with availability queries.

---

## 2026-01-17 - US-007: Create StaffSQLiteService
Commit: 6e43671

**Why this story?** US-007 is the only story with all dependencies satisfied. It depends on US-006 (just completed) and follows the same service pattern for staff members with availability queries.

**Changes:**
- `packages/sqlite-adapter/src/services/staffService.ts` (NEW, 340 lines): Staff SQLite service
  - `StaffSQLiteService`: Extends BaseSQLiteService<Staff, StaffRow>
  - `getAvailable(storeId)`: Staff with status != 'off' (for scheduling)
  - `getByStatus(storeId, status)`: Filter by status (available, busy, break, off)
  - `updateStatus(id, status)`: Quick status update for real-time changes
  - `getActive(storeId)`: Only active (non-deleted) staff members
  - `getByRole(storeId, role)`: Filter by role for permissions
  - `getByStore(storeId)`: All staff for a store with pagination
  - `countByStatus(storeId, status)`: Dashboard metrics
  - `countActive(storeId)`: Count of active staff
  - `softDelete(id)`: Sets isActive=false and status='off'
  - `restore(id)`: Sets isActive=true and status='available'
  - `updateSchedule(id, schedule)`: Update schedule JSON
  - `getBySkill(storeId, skill)`: Find staff with specific skill using json_each()
  - `search(storeId, query)`: Search by name using LIKE
  - `getStatusCounts(storeId)`: SQL GROUP BY for status breakdown
  - `getByEmail(email)`, `getByPhone(phone)`: Lookup by contact
  - Types: `Staff`, `StaffRow`, `StaffStatus`, `StaffRole`, `StaffSchedule`, `ScheduleEntry`
- `packages/sqlite-adapter/src/services/index.ts:59-67`: Export StaffSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:61-68`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (staffService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- json_each() is useful for searching within JSON array columns: `SELECT s.* FROM staff s, json_each(s.skills) AS skill WHERE skill.value = ?`
- Staff status is a 4-state enum ('available', 'busy', 'break', 'off') used for real-time availability
- Soft delete pattern: set isActive=false instead of actual deletion, also set status='off'
- SQL GROUP BY with initialization pattern: start with all keys at 0, then fill from query results

**Patterns to sync:**
- Pattern: JSON array search with json_each() - use `json_each(column) AS alias WHERE alias.value = ?` to search within JSON arrays

**Next story suggestion:** US-008 (Create ServiceSQLiteService) - depends on US-007 and continues the service pattern for menu services with category filtering.

---

## 2026-01-17 - US-008: Create ServiceSQLiteService
Commit: 15e5bbb

**Why this story?** US-008 is the only story with all dependencies satisfied. It depends on US-007 (just completed in the last iteration) and continues the same service pattern for menu services with category filtering and search.

**Changes:**
- `packages/sqlite-adapter/src/services/serviceService.ts` (NEW, 330 lines): Service SQLite service
  - `ServiceSQLiteService`: Extends BaseSQLiteService<Service, ServiceRow>
  - `getByCategory(storeId, category)`: Filter services by category (for menu views)
  - `getActive(storeId)`: Only active services (for booking flow)
  - `search(storeId, query)`: Name/description search using SQL LIKE
  - `getByStore(storeId)`: All services with pagination (for admin views)
  - `getCategories(storeId)`: Get distinct category names for navigation
  - `countByCategory(storeId)`: SQL GROUP BY for category breakdown
  - `countActive(storeId)`: Count of active services
  - `softDelete(id)`, `restore(id)`: Soft delete pattern
  - `updateDisplayOrder(updates)`: Batch update for menu reordering
  - `getByPriceRange(storeId, min, max)`: Price range filtering
  - `getByDurationRange(storeId, min, max)`: Duration range filtering
  - `getPopular(storeId, limit)`: Popular services (by display order)
  - Types: `Service`, `ServiceRow`, `ServiceAddOn`, `ServiceVariant`
- `packages/sqlite-adapter/src/services/index.ts:70-77`: Export ServiceSQLiteService and types
- `packages/sqlite-adapter/src/index.ts:69-74`: Export with SQLite prefix aliases

**Quality Checks:**
- Typecheck: PASS (serviceService.ts has no errors; pre-existing errors in factory.ts/adapters unrelated)
- Tests: PASS (62 tests still passing)
- Forbidden strings: PASS (no 'as any', 'Test Client', 'void _')

**Learnings:**
- Services table uses snake_case columns (store_id, is_active, display_order) matching schema convention
- Added extra query methods beyond acceptance criteria (price range, duration range, categories) for completeness
- displayOrder field is critical for menu presentation - batch update method supports drag-and-drop reordering

**Patterns to sync:** None new - follows established BaseSQLiteService patterns

**Next story suggestion:** US-009 (Add missing methods to TicketSQLiteService) - depends on US-008 (just completed) and requires reviewing existing ticketService.ts to identify any missing methods.

---
