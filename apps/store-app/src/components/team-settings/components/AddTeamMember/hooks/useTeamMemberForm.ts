import { useState, useCallback } from 'react';
import { useSelector } from 'react-redux';
import type {
  TeamMemberSettings,
  WorkingDay,
  ServicePricing
} from '../../../types';
import { defaultWorkingHours, mockServices } from '../../../constants';
import { allDefaultRoles } from '../../../../role-settings/constants';
import { teamSettingsTokens } from '../../../constants';
import { isValidEmail } from '../../../validation/validate';
import { selectStoreId, selectTenantId } from '@/store/slices/authSlice';
import { createSupabaseMember } from '@/services/supabase/memberService';
import type { WizardStep, BasicInfo, LoginCredentials } from '../types';
import {
  generateUUID,
  generateRandomPIN,
  generateInviteToken,
  sendCredentialsNotification,
  mapRoleToSupabase,
  getDynamicRoleLabels,
} from '../utils';
import type { StaffRole } from '../../../types';

const dynamicRoleLabels = getDynamicRoleLabels();

interface RoleColor {
  bg: string;
  text: string;
  border: string;
}

interface UseTeamMemberFormProps {
  existingEmails?: string[];
  onSave: (member: TeamMemberSettings) => void;
}

interface UseTeamMemberFormReturn {
  // State
  currentStep: WizardStep;
  isSubmitting: boolean;
  basics: BasicInfo;
  loginCredentials: LoginCredentials;
  showPassword: boolean;
  showPin: boolean;
  inviteLink: string | null;
  workingHours: WorkingDay[];
  services: ServicePricing[];
  errors: Record<string, string>;

  // Setters
  setBasics: React.Dispatch<React.SetStateAction<BasicInfo>>;
  setLoginCredentials: React.Dispatch<React.SetStateAction<LoginCredentials>>;
  setShowPassword: React.Dispatch<React.SetStateAction<boolean>>;
  setShowPin: React.Dispatch<React.SetStateAction<boolean>>;
  setCurrentStep: React.Dispatch<React.SetStateAction<WizardStep>>;

  // Handlers
  handleNext: () => void;
  handleBack: () => void;
  handleSubmit: () => Promise<void>;
  toggleWorkingDay: (dayIndex: number) => void;
  updateShiftTime: (dayIndex: number, field: 'startTime' | 'endTime', value: string) => void;
  toggleService: (serviceId: string) => void;
  toggleAllServices: (category: string, enabled: boolean) => void;

  // Computed
  getRoleColor: (roleId: string) => RoleColor;
  dynamicRoleLabels: Record<string, string>;
  selectedServicesCount: number;
  workingDaysCount: number;
}

export function useTeamMemberForm({
  existingEmails = [],
  onSave,
}: UseTeamMemberFormProps): UseTeamMemberFormReturn {
  const [currentStep, setCurrentStep] = useState<WizardStep>('basics');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Get store info from auth state
  const storeId = useSelector(selectStoreId);
  const tenantId = useSelector(selectTenantId);

  // Form state
  const [basics, setBasics] = useState<BasicInfo>({
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    role: 'stylist',
    title: '',
    bio: '',
  });

  // Login credentials state - PIN is always required by default
  const [loginCredentials, setLoginCredentials] = useState<LoginCredentials>({
    pin: generateRandomPIN(),
    pinAutoGenerated: true,
    enablePasswordLogin: false,
    passwordSetupMethod: 'none',
    password: '',
    sendNotification: true,
    notificationMethod: 'email',
  });
  const [showPassword, setShowPassword] = useState(false);
  const [showPin, setShowPin] = useState(false);
  const [inviteLink, setInviteLink] = useState<string | null>(null);

  const [workingHours, setWorkingHours] = useState<WorkingDay[]>(defaultWorkingHours);
  const [services, setServices] = useState<ServicePricing[]>(
    mockServices.map(s => ({ ...s, canPerform: false }))
  );

  // Validation
  const [errors, setErrors] = useState<Record<string, string>>({});

  const validateBasics = useCallback(() => {
    const newErrors: Record<string, string> = {};

    if (!basics.firstName.trim()) {
      newErrors.firstName = 'First name is required';
    } else if (basics.firstName.length > 100) {
      newErrors.firstName = 'First name must be 100 characters or less';
    }
    if (!basics.lastName.trim()) {
      newErrors.lastName = 'Last name is required';
    } else if (basics.lastName.length > 100) {
      newErrors.lastName = 'Last name must be 100 characters or less';
    }
    if (!basics.email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!isValidEmail(basics.email)) {
      newErrors.email = 'Please enter a valid email address';
    } else if (existingEmails.map(e => e.toLowerCase()).includes(basics.email.trim().toLowerCase())) {
      newErrors.email = 'This email is already in use by another team member';
    }
    if (!basics.phone.trim()) {
      newErrors.phone = 'Phone is required';
    } else if (basics.phone.length > 20) {
      newErrors.phone = 'Phone must be 20 characters or less';
    }
    if (basics.bio && basics.bio.length > 1000) {
      newErrors.bio = 'Bio must be 1000 characters or less';
    }

    // PIN is always required for all staff
    if (!loginCredentials.pin) {
      newErrors.pin = 'PIN is required for all staff members';
    } else if (!/^\d{4,6}$/.test(loginCredentials.pin)) {
      newErrors.pin = 'PIN must be 4-6 digits';
    }

    // Password validation only if manual password setup is enabled
    if (loginCredentials.enablePasswordLogin && loginCredentials.passwordSetupMethod === 'manual') {
      if (!loginCredentials.password) {
        newErrors.password = 'Password is required';
      } else if (loginCredentials.password.length < 6) {
        newErrors.password = 'Password must be at least 6 characters';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [basics, existingEmails, loginCredentials]);

  const handleNext = useCallback(() => {
    if (currentStep === 'basics') {
      if (!validateBasics()) return;
      setCurrentStep('schedule');
    } else if (currentStep === 'schedule') {
      setCurrentStep('services');
    } else if (currentStep === 'services') {
      setCurrentStep('review');
    }
  }, [currentStep, validateBasics]);

  const handleBack = useCallback(() => {
    if (currentStep === 'schedule') {
      setCurrentStep('basics');
    } else if (currentStep === 'services') {
      setCurrentStep('schedule');
    } else if (currentStep === 'review') {
      setCurrentStep('services');
    }
  }, [currentStep]);

  const handleSubmit = useCallback(async () => {
    setIsSubmitting(true);

    const now = new Date().toISOString();
    let memberId = generateUUID();
    const deviceId = typeof window !== 'undefined' ? `device-${window.navigator.userAgent.slice(0, 10)}` : 'web';

    // Always create member in Supabase with PIN (and optionally password)
    if (storeId) {
      try {
        let passwordHash = '';
        let newInviteLink: string | null = null;

        if (loginCredentials.enablePasswordLogin) {
          if (loginCredentials.passwordSetupMethod === 'manual') {
            passwordHash = loginCredentials.password;
          } else if (loginCredentials.passwordSetupMethod === 'invite') {
            const inviteToken = generateInviteToken();
            passwordHash = `PENDING:${inviteToken}`;
            const baseUrl = window.location.origin;
            newInviteLink = `${baseUrl}/setup-account?token=${inviteToken}&email=${encodeURIComponent(basics.email.trim().toLowerCase())}`;
            setInviteLink(newInviteLink);
          }
        }

        const supabaseMember = await createSupabaseMember({
          name: `${basics.firstName.trim()} ${basics.lastName.trim()}`,
          email: basics.email.trim().toLowerCase(),
          password_hash: passwordHash,
          pin: loginCredentials.pin,
          phone: basics.phone.trim(),
          role: mapRoleToSupabase(basics.role),
          store_ids: [storeId],
          tenant_id: tenantId || undefined,
        });

        if (supabaseMember) {
          memberId = supabaseMember.id;

          // Send notification if enabled
          if (loginCredentials.sendNotification) {
            await sendCredentialsNotification({
              method: loginCredentials.notificationMethod,
              email: basics.email.trim().toLowerCase(),
              phone: basics.phone.trim(),
              firstName: basics.firstName.trim(),
              pin: loginCredentials.pin,
              password: loginCredentials.enablePasswordLogin && loginCredentials.passwordSetupMethod === 'manual'
                ? loginCredentials.password : undefined,
              inviteLink: newInviteLink || undefined,
            });
          }
        } else {
          throw new Error('Failed to create member');
        }
      } catch (error) {
        console.error('Failed to create Supabase member:', error);
        setErrors({ submit: 'Failed to create member. Please try again.' });
        setIsSubmitting(false);
        return;
      }
    }

    // Create the new team member with all sync fields
    const newMember: TeamMemberSettings = {
      // Syncable entity fields
      id: memberId,
      tenantId: tenantId || 'default-tenant',
      storeId: storeId || 'default-store',
      syncStatus: 'local',
      version: 1,
      vectorClock: { [deviceId]: 1 },
      lastSyncedVersion: 0,
      createdAt: now,
      updatedAt: now,
      createdBy: 'system',
      createdByDevice: deviceId,
      lastModifiedBy: 'system',
      lastModifiedByDevice: deviceId,
      isDeleted: false,

      // Profile
      profile: {
        id: memberId,
        firstName: basics.firstName.trim(),
        lastName: basics.lastName.trim(),
        displayName: `${basics.firstName.trim()} ${basics.lastName.trim()[0]}.`,
        email: basics.email.trim().toLowerCase(),
        phone: basics.phone.trim(),
        title: basics.title?.trim() || dynamicRoleLabels[basics.role],
        bio: basics.bio?.trim(),
        hireDate: new Date().toISOString().split('T')[0],
      },
      services: services,
      workingHours: {
        regularHours: workingHours,
        timeOffRequests: [],
        scheduleOverrides: [],
        defaultBreakDuration: 30,
        autoScheduleBreaks: true,
      },
      permissions: {
        role: basics.role,
        permissions: [],
        canAccessAdminPortal: ['owner', 'manager'].includes(basics.role),
        canAccessReports: ['owner', 'manager', 'senior_stylist'].includes(basics.role),
        canModifyPrices: ['owner', 'manager'].includes(basics.role),
        canProcessRefunds: ['owner', 'manager'].includes(basics.role),
        canDeleteRecords: ['owner', 'manager'].includes(basics.role),
        canManageTeam: ['owner', 'manager'].includes(basics.role),
        canViewOthersCalendar: true,
        canBookForOthers: ['owner', 'manager', 'receptionist'].includes(basics.role),
        canEditOthersAppointments: ['owner', 'manager'].includes(basics.role),
        pinRequired: true,
        pin: loginCredentials.pin,
      },
      commission: {
        type: 'percentage',
        basePercentage: 40,
        productCommission: 10,
        tipHandling: 'keep_all',
      },
      payroll: {
        payPeriod: 'bi-weekly',
      },
      onlineBooking: {
        isBookableOnline: true,
        showOnWebsite: true,
        showOnApp: true,
        maxAdvanceBookingDays: 30,
        minAdvanceBookingHours: 2,
        bufferBetweenAppointments: 10,
        bufferType: 'after',
        allowDoubleBooking: false,
        maxConcurrentAppointments: 1,
        requireDeposit: false,
        autoAcceptBookings: true,
        acceptNewClients: true,
        displayOrder: 99,
      },
      notifications: {
        email: {
          appointmentReminders: true,
          appointmentChanges: true,
          newBookings: true,
          cancellations: true,
          dailySummary: false,
          weeklySummary: false,
          marketingEmails: false,
          systemUpdates: true,
        },
        sms: {
          appointmentReminders: true,
          appointmentChanges: true,
          newBookings: true,
          cancellations: true,
          urgentAlerts: true,
        },
        push: {
          appointmentReminders: true,
          newBookings: true,
          messages: true,
          teamUpdates: true,
        },
        reminderTiming: {
          firstReminder: 24,
        },
      },
      performanceGoals: {},
      isActive: true,
    };

    try {
      onSave(newMember);
      // If invite was used, show success step with link
      if (loginCredentials.enablePasswordLogin && loginCredentials.passwordSetupMethod === 'invite' && inviteLink) {
        setCurrentStep('success');
      }
    } catch (error) {
      console.error('Failed to save new team member:', error);
      setErrors({ submit: 'Failed to save team member. Please try again.' });
    } finally {
      setIsSubmitting(false);
    }
  }, [basics, loginCredentials, workingHours, services, storeId, tenantId, inviteLink, onSave]);

  // Get role color from dynamic roles or fallback to static tokens
  const getRoleColor = useCallback((roleId: string): RoleColor => {
    const roleDef = allDefaultRoles.find(r => r.id === roleId);
    if (roleDef) {
      // Convert Tailwind classes to color values
      const bgMatch = roleDef.color.bg.match(/bg-(\w+)-(\d+)/);
      const textMatch = roleDef.color.text.match(/text-(\w+)-(\d+)/);
      const borderMatch = roleDef.color.border.match(/border-(\w+)-(\d+)/);

      if (bgMatch && textMatch && borderMatch) {
        // Return color token values for dynamic styling
        const colorMap: Record<string, string> = {
          'amber-100': '#fef3c7', 'amber-700': '#b45309', 'amber-300': '#fcd34d',
          'purple-100': '#f3e8ff', 'purple-700': '#7c3aed', 'purple-300': '#c4b5fd',
          'blue-100': '#dbeafe', 'blue-700': '#1d4ed8', 'blue-300': '#93c5fd',
          'cyan-100': '#cffafe', 'cyan-700': '#0e7490', 'cyan-300': '#67e8f9',
          'brand-100': '#ccfbf1', 'brand-700': '#0f766e', 'brand-300': '#5eead4',
          'green-100': '#dcfce7', 'green-700': '#15803d', 'green-300': '#86efac',
          'pink-100': '#fce7f3', 'pink-700': '#be185d', 'pink-300': '#f9a8d4',
          'gray-100': '#f3f4f6', 'gray-700': '#374151', 'gray-300': '#d1d5db',
        };

        return {
          bg: colorMap[`${bgMatch[1]}-${bgMatch[2]}`] || '#cffafe',
          text: colorMap[`${textMatch[1]}-${textMatch[2]}`] || '#0e7490',
          border: colorMap[`${borderMatch[1]}-${borderMatch[2]}`] || '#67e8f9',
        };
      }
    }
    // Fallback to static tokens
    return teamSettingsTokens.roleColors[roleId as StaffRole] || teamSettingsTokens.roleColors.stylist;
  }, []);

  const toggleWorkingDay = useCallback((dayIndex: number) => {
    setWorkingHours(prev => prev.map((day, i) =>
      i === dayIndex
        ? {
            ...day,
            isWorking: !day.isWorking,
            shifts: !day.isWorking ? [{ startTime: '09:00', endTime: '18:00' }] : []
          }
        : day
    ));
  }, []);

  const updateShiftTime = useCallback((dayIndex: number, field: 'startTime' | 'endTime', value: string) => {
    setWorkingHours(prev => prev.map((day, i) =>
      i === dayIndex && day.shifts[0]
        ? { ...day, shifts: [{ ...day.shifts[0], [field]: value }] }
        : day
    ));
  }, []);

  const toggleService = useCallback((serviceId: string) => {
    setServices(prev => prev.map(s =>
      s.serviceId === serviceId ? { ...s, canPerform: !s.canPerform } : s
    ));
  }, []);

  const toggleAllServices = useCallback((category: string, enabled: boolean) => {
    setServices(prev => prev.map(s =>
      s.serviceCategory === category ? { ...s, canPerform: enabled } : s
    ));
  }, []);

  const selectedServicesCount = services.filter(s => s.canPerform).length;
  const workingDaysCount = workingHours.filter(d => d.isWorking).length;

  return {
    // State
    currentStep,
    isSubmitting,
    basics,
    loginCredentials,
    showPassword,
    showPin,
    inviteLink,
    workingHours,
    services,
    errors,

    // Setters
    setBasics,
    setLoginCredentials,
    setShowPassword,
    setShowPin,
    setCurrentStep,

    // Handlers
    handleNext,
    handleBack,
    handleSubmit,
    toggleWorkingDay,
    updateShiftTime,
    toggleService,
    toggleAllServices,

    // Computed
    getRoleColor,
    dynamicRoleLabels,
    selectedServicesCount,
    workingDaysCount,
  };
}

export default useTeamMemberForm;
